[{"title":"2020年買ってよかった本【技術書編】","contentSnippet":"株式会社NoSchoolでCTOを務めているmeijinです。普段はWeb技術全般を駆使して開発業務に取り組んでいます。2020年に買ってよかった技術書をまとめます。続きをみる","link":"https://note.com/meijin_garden/n/n809f6300e16a","isoDate":"2020-12-30T08:09:54.000Z","dateMiliSeconds":1609315794000,"authorName":"Meijin"},{"title":"Viewport Units BuggyfillとpurgeCSSを併用するときはappendToBodyを付ける","contentSnippet":"小ネタです。Viewport Units Buggyfillは、iOS Safari で vh を使ったスタイル指定をしたときに表示が崩れてしまうといった問題に対処できるライブラリです。以下のように、例えば Vue であれば実行しておくだけで実行したページ内の vh の問題を修正しておいてくれます。                      onMounted(async () => {  // iOS Safariで100vhを完璧には判定してくれない問題に対するPolyfill  // @see https://github.com/rodneyrehm/vie...","link":"https://zenn.dev/meijin/articles/0ba98f339fd451fdd7cc","isoDate":"2020-12-23T06:18:06.000Z","dateMiliSeconds":1608704286000,"authorName":"Meijin"},{"title":"LaravelにDDDを導入して1年経った所感(達成したこと / 課題点 / モデリングの難しさなど)","contentSnippet":"背景昨年公開したこちらの記事「Laravel でドメイン駆動設計(DDD)を実践し、Eloquent Model 依存の設計から脱却する」の続編です。弊社で開発している「オンライン家庭教師マナリンク」の実装に DDD のアプローチを用いています。導入して 1 年が経過したので、いろいろと所感を述べていきます。目次どうして DDD を導入したかDDD で達成できたことまだ難しいと思うこと結局モデリングが一番難しいどうして DDD を導入したのか？導入した当初の動機は Laravel で Eloquent Model 中心に実装するアーキテクチャに嫌気が差したからです。Eloquent Model 中心に実装するとあちこちにドメイン知識が散らばって、実装した自分ですらよくわからない、という状態によく陥りました。弊社はベンチャー企業で、トラフィックの多さを設計で考慮することはあまり無いのですが、一方で機能追加が盛んなため、より問題が顕著でした。DDD を実践した期間導入して 1 年、と言いましたが、今年実装したものを思い返すと、決済機能（決済処理、決済の対象となる指導コースの CRUD、各種社内管理画面等）に 4 ヶ月先生 ↔ 生徒のコミュニケーションツール開発に 3 ヶ月（Nuxt↔Firebase↔React Native）先生検索機能に 2 ヶ月ドメイン変更 2 ヶ月（事業のピボット）その他 1 ヶ月という感じで、DDD をやったのは決済周りなので、4 ヶ月程度しかやってないですね。※フロントエンドは簡易的な Repository パターンとか Hooks を導入する程度で、DDD はやっていないです。実装した PHP のクラス数は雑に見て 200〜300 くらい、テストコードは 100 くらいでした（普段結合テストしか書いてないことがバレるｗ）。DDD で達成できたことDDD を導入することで達成できたことを、【アーキテクチャ】と【ドメイン】の観点でまとめます。【アーキテクチャ】Eloquent Model からの脱却まず、先の記事のタイトルにもあった”Eloquent Model からの脱却”ですが、一言でいうと達成できました。Eloquent Model の各クラスには以下のような変化がもたらされました。個々の機能でのみ使われるような実装がなくなった結果として、リレーションの定義や、ごくわずかな Scope が残りましたそして、そのために以下の方針で実装を行ってきました。Repository でのみ Eloquent Model を活用するRepository では取得したデータは原則として Entity に詰め替えて返すものすごくシンプルな Repository Interface の例を貼っておきます。Repository の戻り値が Entity になっているのがポイントです。<?phpnamespace Packages\\XXXXX\\Domain\\Repository;use Packages\\XXXXX\\Domain\\Entity\\GeneralUser;interface GeneralUserRepositoryInterface{    public function find(int $id): ?GeneralUser;}【ドメイン】Entity にモデルの振る舞いを表現させる機能名を表す namespace (ここでは”XXXXX”) の配下に 一般ユーザーを Entity とした\"GeneralUser \"というクラスを用意し、メソッドとして一般ユーザーがサービス上で行う振る舞いを実装していきます。以下のようなイメージです。namespace Packages\\XXXXX\\Domain\\Entity;interface GeneralUserEntityInterface{    /**     * ユーザーは問い合わせと、支払いと、問い合わせのキャンセルができることがInterfaceだけ見ると読み取れる     */    public function inquire(Teacher $teacher): Inquiry;    public function makePayment(Inquiry $inquiry);    public function cancelInquiry(Inquiry $inquiry);}※Entity の Interface までわざわざ作成することはさほど多くないですが、たまに作ります以上のように、機能ごとに異なるふるまいを持っている Entity を切っていくことで Eloquent Model の責務を削るというアーキテクチャ上のメリットはもちろん、サービス上で誰(アクター)が何をできるのかが機能ごとに明示されるようになり、ドメイン知識が明確になるというメリットを得ました。まだ難しいと思うこと続いて、DDD を実践する上で難しいと思うことを書きます。一覧系で Entity を使うと問題が生じるEntity を中心に設計していると、一覧系のページが増えるに従って、どんどん Entity が肥大化していってしまう問題が浮上しました。どうして一覧系で Entity を使うと肥大化するのか？一覧画面で表示したいデータと、Entity に持たせるべきデータが必ずしも一致しないからです。例えば弊社ですと、オンライン家庭教師の一覧画面で、各先生にその先生が用意しているオンライン指導のプラン（指導コースと呼んでいます）を 最大 3 件付帯して表示する、という要件がありました。ここで、先生に指導コースを付帯して表示するためには、Teacher Entity に $courses といった命名のプロパティを持たせることで、表示系でも使えます。しかし、この方法には「画面ごとに指導コースの取得ロジックや件数が違っていると、表示最適化のために Entity がどんどん Fat になっていく」という懸念があります。この画面では３件、あの画面では５件、この画面ではこの科目の指導コースに絞って最大３件、といった感じで条件が変わってくると Entity が肥大化します。Teacher Entity にgetCoursesForHogeHogeListPage()といったメソッドが次々増えていくのは本来ドメインモデルがやるべき責務なのか？という悩みがあります。言ってしまえば SEO 対策のために作るページも多いので、そこに Entity を使っているとどんどん表示ロジックが増えていきます。対処方針思いついた実装方針を 3 つ挙げてみました。私は(大半のケースにおいて)一番最初の方針を採択しています。取得系の処理は、Entity にデータを詰め込まずに、専用の DTO クラス（API Resource のような責務）を使う検索系の処理は Repository から返す値をそもそも DTO のクラス型にするAPI のパスから DTO まで一気通貫で分かりやすく namespace 等を管理できたり、OpenAPI の Model と上手に連携し、ViewModel のような概念で扱えるともっと良いのかもしれない諦めて取得系の処理は Eloquent Model をそのまま取り回す表示のための Attribute が Eloquent Model に生えまくって本末転倒感があるDDD をやるほどでもない機能や事業領域にはこちらを採用しています。正直言うと上記で例示した先生の一覧ページでは単に Eloquent Model の Collection を API Resource に入れてまるっと返していますRead はデータソースごと切り替えられるようにして CQRS にガッツリ取り組む弊社はそんな事業規模じゃない(≒DB のパフォーマンスがボトルネックになっていない)とはいえ、事業規模が小さいなら DDD やらなくていいとか、適当に実装していいかというと別の問題。ちょうどいいバランスを模索していきたい結局モデリングが一番難しい一周回ってここ最近は DDD で一番難しいのは結局モデリングだなと思っています。昨年初めて Laravel×DDD に取り組み始めた頃は、PHP でどうやって Entity を表現するか？ValueObject を表現するか？Enum は？といった実装レイヤの悩み事が多かったです。まあ今も多いんですが。しかし、そのあたりに慣れてくると、そもそもモデリングの時点でどれくらい精度高くドメインモデルが導き出せるか、また、実装しながらどれだけモデリングを磨き込んでいけるかが重要なのではと思えてきました。モデリングとはなにか？（※個人的な定義です）要件はいつも文章で表現されますが、文章というのは大変曖昧だし複雑です。見ただけでは「生徒」「オンライン家庭教師」「料金」「支払う(という行為)」が浮かびますが、ここにさらに「支払えるか支払えないかの前提条件」とか「支払うことのできる料金の範囲」といったルール的な概念もあれば、オンライン家庭教師から見ると生徒に支払ってもらった金額は「売上」に該当するので、「売上」というそもそも要件に現れていないモデルも見えてきます。このように、要件に出てくる登場人物、アクション、条件、アクションの結果生成されるデータといったモデルを見抜き、それらの関連性を見出すのがモデリングです。モデリングが大事だと思う理由は？要件の抜け漏れを発見できたり、要件の広がりに答えられる可能性を作れるからです。モデル同士の関連性を図に表していると、「あれ？ここって 1:1 のつもりで書いているけど 1:多にならん？」といった初歩的な見落としに気がついたり、稀にですが「この登場人物とこっちの登場人物は汎化の関係になってないか？」といった、最終的に Interface や抽象クラスに落とし込めるヒントを得たりすることがあります。実践 DDD といった書籍も読みましたが、書籍は引き出しを与えてくれるだけで、実際にどの引き出しをいつ開くかは自分が決めるべき、といった感じです。つまるところ、DDD のパターンを脳死で導入しないためにモデリングをしている気がします。私はドメインサービスとかイベントはあまり使わないようにしています。知った当初は面白い概念だなと思いましたが、モデリングも実装もままならないうちにこれらに手を出すとカオスになりました。実装が落ち着いたり、サービスの検証を回していって要件がしっかり固まってきた頃に見返すと、ここはドメインサービスが必要そうだ、といったことがようやく見えてきた気がします。どうやってモデリングしているか？ユースケース図を書くか、クラス図を書いています。クラス図を plantUML で書くのがお気に入りなのですが、本当は紙とかホワイトボードをもっと使いこなすほうがいいのかもしれないです。なんだか plantUML 書くのに必死で発想に集中できない気がするんですよね。クラス図がモデリングとイコールかというと違う気もしますし・・・plantUMLの例@startuml テスト用note top of samplePackageノートを書くことができるend notepackage samplePackage {    class InquireUser    InquireUser : id: UserId    InquireUser : +makePayment(Teacher, amount): PaymentHistory    class Teacher    Teacher : id: TeacherId    InquireUser \"0..1\" -- \"*\" Teacher    class PaymentHistory    PaymentHistory : teacherId    PaymentHistory : +getUserPaid()    PaymentHistory : +getUserId()    PaymentHistory : +getCreatedAt()    InquireUser \"0..1\" -- \"*\" PaymentHistory}@enduml実際モデリングする時間はあるのか？実際、モデリングだけで丸 1 日掛けてます！とかは無いです。長くても数時間で終わらせたら少しずつソースコードを書きます。まずは Entity や ValueObject から書いて、Repository の Interface だけ書いて、組み合わせて UseCase を作っていくわけですが、節目節目で不自然なところがないか振り返り、こうやったほうがより的確な表現なのではと思ったら更新していきます。Repository は Interface だけ書くことで、データベース設計と脳味噌を働かせるタイミングを分けて、API も作らず UseCase までで留めて一旦書き上げることで、ついついフロントエンドを実装したい衝動を抑えたりしています。延々とモデリングばかりして動くものを作らないと事業としては意味がないので、開発速度はできるだけ変えずに、開発の進め方を改善している感じです。その他所感とか言いたいことEnum 便利Enum は以下の抽象クラスを使っています。便利です。<?phpnamespace Packages\\Base\\Domain\\ValueObject;use InvalidArgumentException;use ReflectionObject;/** * @see https://speakerdeck.com/twada/php-conference-2016?slide=40 */abstract class Enum{    private $scalar;    public function __construct($value)    {        $ref = new ReflectionObject($this);        $consts = $ref->getConstants();        if (! in_array($value, $consts, true)) {            throw new InvalidArgumentException(\"value [$value] is not defined.\");        }        $this->scalar = $value;    }    final public static function __callStatic($label, $args)    {        $class = get_called_class();        $const = constant(\"$class::$label\");        return new $class($const);    }    final public function value()    {        return $this->scalar;    }    final public function __toString()    {        return (string)$this->scalar;    }}ValueObject をもっと上手くなりたいValueObject のモデリングについては、先日以下のツイートを見かけまして、ValueObject にはまだまだ開拓の余地があるなと思いました。ビジネスルールを表現する５点セット。値オブジェクト（金額、数量、日付、地点、...)区分オブジェクト(商品区分、サービス区分、状態区分、...)範囲オブジェクト(価格帯、期間、地域、...)コレクションオブジェクト(順序・集合・写像）表オブジェクト（価格表、判定表、...)— 増田 亨． (@masuda220) December 5, 2020 まだまだビジネスルールを UseCase に書いてしまっている余地がありそうです。範囲オブジェクト、区分オブジェクトあたりは結構 if 文で済ませてしまっているような気がします。ルールを個別のオブジェクトとして明示することで、より仕様をソースコードで表現しやすくなるように見えます。モデリングの段階で、こういった条件や範囲を意識的にモデリングするとソースコードにも反映できやすそうです。Interface は神最近抽象クラスを使わずに Interface で疎結合に組むのが楽しいです。Repository だけではなく、外部アクセスも Interface にします。また、これはOOPの話になりますが、特定の Entity に特定の振る舞いを持たせるためにその振る舞いのみを持った Interface を Implements させる（つまり、複数の Interface を Implements した Entity を作ったり、Interface を Implements した抽象 Entity クラスを作り、その拡張として実 Entity を作成する）など、Interfaceを有効活用してEntityを組むのも割と好きです。▼ 参考 この質疑応答がとてもいいですhttps://softwareengineering.stackexchange.com/questions/398455/depend-on-ddd-entities-or-interfacesUsing Object-Oriented Programming techniques helps you define your domain model and describe the state of all entities, as well as the relations between different entities.テストコードは神PHPUnit でテストコードを書くようにしています。ほとんど API 単位の結合テストだけしか書いていないのにも関わらず、大変品質に貢献してくれています。GitHub Actions で自動テストを回すので、思わぬデグレをほとんど事前に防ぐことができます。来年は「テストデータの整備」「単体テストにもチャレンジ」「フロントエンドでも jest×composition-api でテスタブルにする」あたりを標語に頑張っていこうと思います。まとめドメイン駆動設計を導入して 1 年間運用することで達成できたことと、今後の課題点を述べてきました。アーキテクチャ面では Entity を使いこなすことで Eloquent Model への依存を実際に卒業できました。ドメインをモデリングする部分はまだまだ上達の余地があると考えており、アーキテクチャや設計パターンへの理解を深めることと両軸で上達していくことが重要だと思っています。告知私が CTO を務めている「オンライン家庭教師マナリンク」では、エンジニアを募集しております。2020 年 12 月 現在、Web エンジニア及び、React Native エンジニアを探しております。本日のLTスライドです！PHPUnitで単発/月額決済ありサービスを自動テストしている話https://t.co/8K3jXUITRr #laravellt— 名人さん｜オンライン家庭教師マナリンクCTO (@Meijin_garden) November 25, 2020 マナリンクでは、オンライン家庭教師の先生方のために、サイト上で自身のプロフィールを魅力的に発信できるようにしたり、オンライン指導専用アプリをリリースするなど、次々にプロダクトを開発しています。日々新しい技術を勉強して、試す機会を探している方にはうってつけな環境です。ベンチャー企業ですが、CTO/CEO ともにテストコードを使って品質保持することに理解はありますし、オンライン家庭教師という新しい働き方のドメインを作っていくという意味で、問題解決領域としても大変興味深いのではと思っています。興味あれば 上記の Twitter に DM でご連絡をください！","link":"https://qiita.com/mejileben/items/348d70e28fdbb3a0749f","isoDate":"2020-12-16T13:33:06.000Z","dateMiliSeconds":1608125586000,"authorName":"Meijin"},{"title":"サーバーサイドTS【NestJS/FoalTS/frourio】でDI/API実装/Fastify連携/etcを比較した","contentSnippet":"概要サーバーサイド TypeScriptのフレームワークで、個人的に有力視している以下の 3 フレームワークを比較します。FoalTSNestJSfrourio主な比較項目は以下のとおりです。Controllerの書きやすさ(バリデーション含む)Dependency Injectionの書きやすさ、テストの実装のしやすさFastify連携の対応可否※frourio は Next.js をフロントに Integration したフルスタックフレームワークとしての一面がありますが、API 鯖としても便利だと思っているので、本記事は APIの活用にフォーカスして...","link":"https://zenn.dev/meijin/articles/840306d41c103eb5a962","isoDate":"2020-12-06T09:41:36.000Z","dateMiliSeconds":1607247696000,"authorName":"Meijin"},{"title":"docker-compose × Firebase Emulatorでローカル環境構築","contentSnippet":"※本記事はこちらのスライドを marp で変換して作成する元になった markdown ファイルですFirebase の使いどころオンライン家庭教師と、学生＆親御さんが使うチャットに利用Web(Nuxt.js) ⇔ スマホアプリ(React Native)Firebase Auth & Firestore & Storage を利用ちなみに、Nuxt.js では composition-api を使って Firebase 用のフックを作成していますvue-composition-api で Firestore を扱う react-firebase-...","link":"https://zenn.dev/meijin/articles/marp-firebase-emulator","isoDate":"2020-11-30T11:44:24.000Z","dateMiliSeconds":1606736664000,"authorName":"Meijin"},{"title":"IT事業は「サービス」と「ソフトウェア」に分類でき、その分類によってDDDを適用すべきかが決まるのでは、という考察","contentSnippet":"先日、こんなツイートを見かけました。ツイートの中で、以下の発言が気になりました。                      日本はサービスには投資するけど、ソフトウェアに投資する人は皆無            本当に投資が皆無かどうかはデータを見ないとわからないとして、私は、IT 事業を大きく「サービス」と「ソフトウェア」に分類したことに注目しました。また、私は普段 Web 開発に関わるエンジニアなのですが、ドメイン駆動設計（以下、DDD）とどのように向き合うのがいいかをよく思案しています。そこで、今回は、「事業がサービスとソフトウェアのどちらに分類されるか」と「...","link":"https://zenn.dev/meijin/articles/5cb73354486ec0eb54b3","isoDate":"2020-11-28T07:10:28.000Z","dateMiliSeconds":1606547428000,"authorName":"Meijin"},{"title":"[PHP]composer2系になってデプロイが落ちるようになった人はバージョン指定してインストールしよう","contentSnippet":"概要2020 年 10 月 24 日、composer 2.0 へのメジャーアップデートが実施されました。弊社のサービスがこれを原因として Dockerfile 内の composer 周りのコマンドが落ちてしまうようになったので、暫定対処としてバージョン指定しました。やり方（推奨）--1オプションを指定します。上記のメジャーアップデート告知の記事に書かれています。Should you encounter issues, you can go back at any time by using composer self-update --1. Hopefully that ...","link":"https://zenn.dev/meijin/articles/09f5a7f70db286cf792d","isoDate":"2020-10-26T02:59:40.000Z","dateMiliSeconds":1603681180000,"authorName":"Meijin"},{"title":"Next.js × TSX に Zero-runtime CSS in JS の linaria を導入する","contentSnippet":"Next.js9.5 系に linaria を導入する方法を解説します。個人的に結構有名な組み合わせかと思っていましたがググっても見つからず、少し苦労したので記事にしておきます。linaria とはNext.js については React の Web アプリケーション向けフレームワークということで知名度が高いと思いますが、 linaria についてはまだ知名度が比較的低いかもしれません。特筆すべき特徴として、Write CSS in JS, but with zero runtime, CSS is extracted to CSS files during buildが挙げられて...","link":"https://zenn.dev/meijin/articles/a8163992c8e845fb382f","isoDate":"2020-10-15T14:50:36.000Z","dateMiliSeconds":1602773436000,"authorName":"Meijin"},{"title":"[CSS]アニメーション終了時点でのスタイルをそのまま保持する","contentSnippet":"小ネタです。CSS で、最初は非表示になっていた要素を出現させるアニメーションをやったとき、アニメーション終了時に本来のスタイル、すなわち非表示に戻ってしまうことがありました。調べてみると、下記の CSS を一行足すだけで、終了時点でのスタイルを保持してくれました。                      animation-fill-mode: forwards;            終了時点というのは、厳密には keyframe にて 100%と指定されているスタイルです。一応、MDNによれば、animation-direction と animation-...","link":"https://zenn.dev/meijin/articles/animation-style-save","isoDate":"2020-10-14T09:56:31.000Z","dateMiliSeconds":1602669391000,"authorName":"Meijin"},{"title":"Webエンジニア論語","contentSnippet":"子曰く、PHP 学びて PHPStorm 使わざれば即ち危うし背景JetBrains 社による PHP 用の IDE であるPHPStormの優秀さに惚れ込んだ 孔子（以下、先生） が、弟子たちに話した内容とされています。意訳PHP を学んでいる弟子エンジニアの皆さん、 PHPStorm をぜひ利用しましょう。 PHPStorm を使っていないことは大変危険なことです。エディタに金を貢ぎましょう。 VSCode × intelephense より全然優秀だと先生は思いますよ。Laravel エンジニアの皆さんには、 PHPStorm のおすすめプラグインがまとまったこちらの記...","link":"https://zenn.dev/meijin/articles/web-engineer-rongo","isoDate":"2020-09-26T12:43:25.000Z","dateMiliSeconds":1601124205000,"authorName":"Meijin"},{"title":"vue-composition-apiで作るカスタムHook入門〜useHoge()を自作してみよう〜","contentSnippet":"概要vue/composition-apiの登場によって, Vue.js でも React の Custom Hook のような関数を簡単に作成できるようになりました.本記事では, vue/composition-apiで作る API 呼び出し用の Hook として「useApi」を紹介しながら, 作成のコツや考え方を説明していきます.また, 最後には useApi 単体でのテストコードも添付しています. Hook のテストコードが気になる方もぜひ読んでください.対象読者vue/composition-apiの存在は知っている, または軽く使ったことがあるReact の...","link":"https://zenn.dev/meijin/articles/34b9482dbc856d2523ed","isoDate":"2020-09-21T11:34:31.000Z","dateMiliSeconds":1600688071000,"authorName":"Meijin"},{"title":"vue/composition-api@1.0.0-beta7で入ったBREAKING CHANGESについて解説する","contentSnippet":"vue/composition-api@ 1.0.0-beta7で入ったBREAKING CHANGESについて解説します。その変更はこちらのURLに記載されています。https://github.com/vuejs/composition-api/releases/tag/v1.0.0-beta.7<template>内でRef型の変数がUnwrapされるのは、setup()で返したオブジェクトのroot levelに限るという内容です。どういうことかcomposition apiのsetup()では、<template>内で扱いたいリアクティブな値をオブジェクトにまとめてreturnします。return {  loading: ref(true),  hogeState: {    loading: ref(true)  }}この場合、vue/composition-api@1.0.0-beta7以前では、以下のように<template>を書くことが出来ました。<span>{{ loading }}</span><span>{{ hogeState.loading }}</span>Ref<T>であれば、本来は値を取り出すために.valueしなければいけないのですが、<template>内であればUnwrapされてT型の値が取り出せるのでスマートに書けるということでした。これが、vue/composition-api@1.0.0-beta7以降では、root levelしかUnwrapされなくなるので以下のように書かないといけません。<span>{{ loading }}</span><span>{{ hogeState.loading.value }}</span>…明らかに書きたくない書き方になりましたね。所感と対策個人的にはこの変更はポジティブだと思っています。そもそもネストした箇所にRef<T>があるということは、setup()内に複数のreactiveなStateがあるなどで、root levelにまとめることが難しかったりややこしいという状況だと思います。// あり得るとしたら、複数のhooksを使っているなどの理由で、同じ名前のRefが生えてしまって仕方なくネストしているとかでしょうかreturn {  hogeState: {    loading: ref(true)  },  fugaState: {    loading: ref(true)  }}その場合、コンポーネントのサイズが大きすぎるでしょうから分割したり、それが難しければ以下のように名前を変更してstateを扱えば済むので、そのように工夫する方が設計的には嬉しいように思います。const { loading: hogeLoading } = useHoge()const { loading: fugaLoading } = useFuga()return {  hogeLoading,  fugaLoading}個人的には1コンポーネント1Stateで済むように、useHogeのサイズ感を適宜インフラ層を用意するなどして工夫することが大事だと考えます。まとめcomposition-apiを既に使っている方で、ネストしたオブジェクトにRef型の変数を入れていそうだなと思う方はなるべく早くアップデートして要チェックです。そうでない方は、頭の片隅にでも入れておいていただければと思います！よろしければTwitterのフォローお願いします！https://twitter.com/Meijin_garden","link":"https://qiita.com/mejileben/items/cbdaef7703fdd6a4c36f","isoDate":"2020-09-13T07:35:20.000Z","dateMiliSeconds":1599982520000,"authorName":"Meijin"},{"title":"vue/composition-apiでscrollの状態を扱うComposition Functionを作った","contentSnippet":"概要上向きにスクロールしたときに表示して、下向きにスクロールしたら隠すフッターを表示する要件が現れたので、useScrollを作成して、スクロールの向きを絶えずリアクティブに返すComposition Functionとして扱ってみました。ソースコードimport { useWindowScroll } from '@vueuse/core'import {  reactive,  toRefs,  watch,} from '@vue/composition-api'export const useScroll = () => {  const { x, y } = process.browser ? useWindowScroll() : { ...toRefs(reactive({x: 0, y: 0})) }  const state = reactive<{    isUp: boolean,    isDown: boolean  }>({    isUp: false,    isDown: false,  })  watch(y, (newY, oldY) => {    state.isUp = newY < oldY    state.isDown = newY > oldY  })  return {    x,    y,    ...toRefs(state),  }}解説こちらのFunctionには、vueuseというライブラリを使わせてもらっています。今回はuseWindowScrollを利用させていただきました。composition-apiのwatchで、スクロールのy値を監視しており、変化したときの古い値との比較によって上昇中か、下降中かを判定しています。使い方こんな感じで書くと、スクロールの向きに応じて出たり消えたりするフッターが作れます。高さが70px決め打ちになっているのが少し悔やまれますが、Vue3でStyle周りの改善が入るらしいのでちょっとそれを心待ちにしていようと思っています。<template>  <footer :style=\"footerStyle\" class=\"sync-scroll\" :class=\"{ appear: isUp }\">    <slot />  </footer></template><script lang='ts'>import {  computed,  defineComponent,} from '@nuxtjs/composition-api'import { useScroll } from '~/composables/utils/window/useScroll'export default defineComponent({  setup() {    const scrollState = useScroll()    const footerStyle = computed(() => {      if (scrollState.isUp) {        return {          height: '70px',        }      }      return {        bottom: '-70px',        height: '70px',      }    })    return {      ...scrollState,      footerStyle,    }  },})</script><style lang='scss' scoped>@import '@/assets/css/variable.scss';.sync-scroll {  width: 100%;  position: fixed;  bottom: -70px;  animation-name: hide;  animation-duration: .4s;  animation-timing-function: linear;  &.appear {    bottom: 0;    animation-name: appear;    animation-duration: .4s;    animation-timing-function: linear;  }}@keyframes appear {  0% {    bottom: -70px;  }  100% {    bottom: 0;  }}@keyframes hide {  0% {    bottom: 0;  }  100% {    bottom: -70px;  }}</style>注意点もとのuseWindowScrollが、スクロールのイベントハンドラにthrottleのような処理を噛ませていないっぽくて、全てのスクロールイベントに対してハンドラを呼び出しているようです。パフォーマンスを重視するならthrottleを噛ませたほうが良いと思います。最後にcomposition-apiにハマって日々いろいろ試して発信しているTwitterアカウントはこちらです。https://twitter.com/Meijin_garden","link":"https://qiita.com/mejileben/items/b686002870664a817c79","isoDate":"2020-09-10T05:43:10.000Z","dateMiliSeconds":1599716590000,"authorName":"Meijin"},{"title":"vue-composition-apiでFirestoreを扱うreact-firebase-hooks風のComposition Functionを作った","contentSnippet":"2020/09/04加筆修正こちらのコメントを @kahirokunn さんから頂いたので、微修正を加えました！細かい所とかだとwatchはimmediateオプションあるとか、query変更時に前のsubscribe解除してないとかありますが、使い勝手は良さそうですね！Converter関数渡すなら、自分で取得したデータをcomputedで変換すればいいので、Converterいらないかなぁとも思いました— { __typename: “kahirokunn” } (@kahirokunn) September 4, 2020 普通にTwitterでシュッと意見を聞いてみただけなのに、Firestoreのリスナ解除していないことを見抜いてしまうあたり場数が違うなあと思いました（僕は手元で動かしてようやく気がついたのでｗ）。概要composition-apiを使ってFirebaseのFirestoreからデータ/ローディング/エラーなどを読み取ることができるComposition Functionを作りました。useCollection.tsと名付けており、useCollectionData<T>というメソッドをexportしています。ソースコードはこちらのGistに上げていますが、本記事ではこの内容についてざっと解説していこうと思います。https://gist.github.com/TeXmeijin/380e52febdae921f31afe382af1bb40fuseCollection活用の全体像まずはこのComposition Functionはどういった仕様か、また、どのようにComponentで活用できるかを説明します。useCollection.tsexport const useCollectionData: useCollectionData = <T extends { id: string }> (  getQuery,  option) => {  const {    snapshot, loading, error,  } = useCollection<T>(getQuery, option)  const values = computed(    () => {      return (snapshot.value        ? snapshot.value.docs.map(doc => {          return {id: doc.id, ...doc.data()}        })        : []) as T[]    }  )  return {    values, loading, error,  }}※本家のreact-firebase-hooksは一度きりの読み取りが可能なHooksも公開していますが、本記事では一旦リアルタイムアップデートを入手できるComposition Functionの作成についてのみ話します。useCollectionData<T>を使うと、下記の型の戻り値が得られます。type CollectionData<T> = {  values: Ref<T[]>,  loading: Ref<boolean>,  error: Ref<Error | null>,}リアクティブに変更されるCollectionの値(values)と、読込中にTrueになるloading、読み込みエラー時にエラー内容が入るerrorが返ってきます。これらは以下のuseMessagesのように具体的な型を指定したアプリケーションのユースケースに沿った別のcomposition functionを挟んだ上でComponentから呼び出して利用します。useMessages.ts// チャットメッセージのフック。部屋の`ID`を指定すると部屋のメッセージ一覧を取得できるexport const useMessages = (roomIdRef: Ref<string>, option = {  limit: 20,}) => {  const messagesState = useCollectionData<Message>(    () => firebase.firestore().collection('messages').where('roomId', '==', roomIdRef.value)      .orderBy('updateTime', 'desc'),    {      dataConverter: messageFirestoreDataConverter,    }  )  return {    ...messagesState,  }}Component.vue  setup (props) {    // @note FirebaseのInitializeは親コンポーネントまたはNuxt Pluginなどにて実行すること    const messagesState = useMessages(computed(() => props.selectedRoomId))    return {      messagesState,    }  },templateは下記のような感じです。Component.vue<template>  <main>    <section>      <div v-if=\"messagesState.loading\">        loading...      </div>      <div v-else-if=\"messagesState.errors\">        {{ messagesState.errors.message }}      </div>      <div v-else>        <ul>          <li v-for=\"message in messagesState.values\" :key=\"message.id\">            <span>{{ message.text }}</span>            <span>{{ message.createTime }}</span>          </li>        </ul>      </div>    </section>  </main></template>ローディングやエラー表示もリアクティブに取得できるため、このようにシンプルな記述でリアクティブなデータ読み込みを実装できます。ここで、setupの戻り値を下記のようにするとtemplate側でmessagesStateと書かなくて良い分書きやすいのでそちらで書いてもいいでしょう。    return {      ...messagesState    }useCollectionDataの概要設計思想設計思想は元祖であるreact-firebase-hooksの同名の関数を真似ています。https://github.com/CSFrequency/react-firebase-hooks/blob/master/firestore/useCollection.tsこちらのライブラリはもとよりReactから提供されているHooksを活用していたり、共通でローディングを扱うHooksとしてuseLoadingValueを実装していたりと、なかなか簡単に複製できそうにないと感じたため、一旦useCollectionDataと近しいものを再現する方針で取り組んでみました。型useCollectionDataの型は下記のように定義しました。export type CollectionData<T> = {  values: Ref<T[]>,  loading: Ref<boolean>,  error: Ref<Error | null>,}type useCollectionData = {  <T extends { id: string }> (    getQuery: () => firestore.Query,    option?: {      dataConverter?: FirestoreDataConverter<T>    }  ): CollectionData<T>}ジェネリック型TはFirestoreから取り出してきたデータの型です。Firestoreの戻り値は基本的にそのままだと型安全ではないので、この段階で型が付けられるようにしています。useCollectionDataのgetQueryは関数で渡すようになっています。これはuseCollection内部で下記のようにcomputedでWrapすることでリアクティブにクエリの変更を受け付けられるようにするためです。  const query = computed(() => getQuery())というのも、チャットルームでメッセージを読み込む処理を開発する場合、部屋を何度も切り替えることが想定されるため、部屋を切り替えるたびに新しくデータを読み取ってほしいからです。そこで、検索クエリ内には検索パラメータが必ず含まれることを利用して、検索パラメータの変更に対して即時に再度クエリを投げてもらうよう設計してみました。戻り値のCollectionDataについては前述の通りです。オプションのdataConverterには、FirestoreDataConverterを指定できます。Converterについての仕様は下記ドキュメントを御覧ください。https://cloud.google.com/firestore/docs/manage-data/add-data?hl=ja#custom_objects読み込み、書き込み時にFirestore上のデータとドメインオブジェクトで変換を掛けることができるハンドラのようなものです。個別のモジュールとして作っておいて適宜importして使うと良いと思います。特にDateはFirestore上のデータの型はTimestamp型として扱われているので、dayjs等で日付のフォーマットを掛けるために下記のように実装してConverterとしています。messageFirestoreDataConverter.tsexport const messageFirestoreDataConverter: FirestoreDataConverter<Message> = {  toFirestore (message: Message): DocumentData {    return message  },  fromFirestore (snapshot: QueryDocumentSnapshot<FirebaseMessage>): Message {    const { createTime, updateTime, ...contents } = snapshot.data()    return {      createTime: convertTimestampToDate(createTime),      updateTime: convertTimestampToDate(updateTime),      ...contents,    }  },}データの読み取りデータの読み取りとそれに関するステートは下記コードによって取得しています。  const {    snapshot, loading, error,  } = useCollection<T>(query, option)useCollectionDataやここで使われるuseCollectionでは徹底的にジェネリック型を使って、ドメインオブジェクトの型を取り回し続けるように組んでいます。useCollectionは下記の通りです。export const useCollection = <T> (  getQuery: () => firestore.Query,  option?: {    dataConverter?: FirestoreDataConverter<T>  }) => {  const snapshotState = reactive<SnapshotState>({    snapshot: undefined,    loading: true,    error: null,  })  const query = computed(() => getQuery())  let listener = () => {  }  const bindSnapshotHandler = () => {    if (!query.value) return    listener()    snapshotState.loading = true    const builtQuery = option?.dataConverter ? query.value.withConverter(option.dataConverter) : query.value    listener = builtQuery.onSnapshot({      next: val => {        snapshotState.snapshot = val        snapshotState.loading = false      },      error: err => {        snapshotState.error = err        snapshotState.loading = false      },    })  }  // マウント完了時か、クエリが変化したときにデータを読み込む  watch(query, bindSnapshotHandler, {immediate: true})  onUnmounted(() => {    listener()  })  return {    ...toRefs(snapshotState),  }}前述のDataConverterを必要に応じて使いながら、watchでsnapshotの取得を試みています。Converterの型定義にジェネリック型が必要になるので、ここまでずっとジェネリック型Tを取り回し続けています。今回はこのように、immediate: trueで即時実行するようにフックを組みましたが、実行するハンドラごと呼び出し元に返して、呼び出し元の裁量で実行タイミングを決められる設計もありだと思います。useDocumentCreate.tsも作っているのですが、そちらはcreateというハンドラを呼び出し元に返しておき、チャットメッセージの送信ボタン押下のイベントハンドラでcallしています。わからないこと2020/09/20追記下記のわからないことですが、クロージャを引数で受け取って、composition function内部でcomputedでWrapすればリアクティブになるので、そのほうが望ましいことに気が付きました。useSWRVがその方式を採用しています。これでとりあえず動作するわけなのですが、ベストプラクティスかどうか分かっていない点としては、下記のようにComputedRefをcomposition functionが受け取る点です。  const readState = useCollectionData<Message>(    computed(() => firebase.firestore().collection('messages').where('roomId', '==', roomIdRef.value)      .orderBy('updateTime', 'desc')),    {      dataConverter: messageFirestoreDataConverter,    }  )あるページ内でクエリが次々変化するケースにおいてのカスタムフックってこのように作る方針でいいんでしょうか。Query型を渡してしまうと、Queryを更新したときに再度フックが走らないのでデータが更新されないわけです。watchなどを基点に再読み込み動かすほうがスッキリ来るような気もする。まとめ自信がない箇所もありますが、なんにせよ通信処理とエラー、ローディングがリアクティブに扱えるモジュールを切り出しやすいcomposition-apiは便利です。ReactのHooksが羨ましいと思っていたのですがcomposition-apiのほうがリアクティブな値の型が明示されている点で直感的な気がしていて好みです。色々試行錯誤してきたいと思います。今のところ、以下でツイートしているように、インフラ層と、DTO(というかドメインオブジェクトの型)に変換する層と、アプリケーション固有の仕様を表現する層にComposition Functionのレイヤーを分けて、ネストさせて扱うと見通しが良さそうに思っています。インフラ：useApi/useFirestoreCollectionなどDTO変換：useArticle/useMessageなどアプリケーション：画面特有の、ここのイベントが動いたらここのデータを再読込するみたいな動きを実装する— 名人さん | マナリンクCTO (@Meijin_garden) September 2, 2020 よろしければTwitterのフォローお願いします！https://twitter.com/Meijin_garden","link":"https://qiita.com/mejileben/items/3a685e95a360d375fd60","isoDate":"2020-09-03T10:58:39.000Z","dateMiliSeconds":1599130719000,"authorName":"Meijin"},{"title":"vue/test-utils で overwriting methods via the `methods` property is deprecated の警告を消す","contentSnippet":"表題の通り、@vue/test-utilsでDeprecatedを由来とするコンソールエラーを非表示にする方法です。環境@vue/test-utils v1.0.4Vue.js v2.6.11事象テスト実行時に下記のようなコンソールエラーが出ます。[vue-test-utils]: overwriting methods via the `methods` property is deprecated and will be removed in the next major version. There is no clear migration path for the `methods` property - Vue does not support arbitrarily replacement of methods, nor should VTU. To stub a complex method extract it from the component and test it in isolation. Otherwise, the suggestion is to rethink those tests.どんなテストコードを書いているかというと、下記のようなコードです。    const methods = {      setUpXXXXX: jest.fn(),    }    const computed = {      user () {        return {}      },    }    const wrapper = shallowMount(Component, {      localVue,      vuetify,      router,      stubs,      methods,      computed,    })上記のように、methodsやcomputedをテストコードから上書きしてモックなどに差し替える方法はVue2.xのテストコードを書く上では便利なのですが、@vue/test-utils v1.0.4時点でDeprecatedとなっております。これは、Vue3以降でcomposition-apiに対応するため、これからはcomposableとしてこれらの処理は全てまとめて切り出し、単体テストを書く流れになることから、methods/computedをVueインスタンスにinjectするようなテスト手法は終りを迎えるという意味だと思っています（これは仮説）。とはいえ、特にNuxt.jsのユーザーの場合は2020年9月現在、まだしばらくはVue2のテストコードを書かなければいけないでしょう。というか僕がそうです（nuxt-composition-apiのメジャーバージョンが待ち遠しい）。対策対象のテストファイルの冒頭に下記のコードを差し込めば、Deprecatedを由来としたコンソールエラーは消えます。import { config } from '@vue/test-utils'config.showDeprecationWarnings = falseよく見たら公式リポジトリにも書いてました。https://github.com/vuejs/vue-test-utils/blob/869b096253e1af0b6121bd4529fa1adc47fda934/docs/api/config.mdこちらのソースを見ると、warnDeprecatedの動作自体が上記Configをもとにして判断していたので、Falseにすればいいのだとわかりました。https://github.com/vuejs/vue-test-utils/blob/39be102165f94897786db3b9db51af09ad419187/packages/shared/util.jsまとめコンソールエラーを汚されると、肝心のコンポーネント読み込み失敗などのWarningが埋もれてしまうので消しました。showDeprecationWarningsでgrepしたら今後Vue3への移行時にも対応できると思うので、一時的な対応ではありますがあとでちゃんと移行することを念頭に置いて実装しましょう。","link":"https://qiita.com/mejileben/items/32b1cbbb2f522601e63d","isoDate":"2020-08-29T08:41:47.000Z","dateMiliSeconds":1598690507000,"authorName":"Meijin"},{"title":"ダサいUIデザインを卒業したいエンジニアが「デザインの基本原則」を使いこなす7つのコツ","contentSnippet":"WebサービスのUIデザインを実施する上では、【対比・近接・反復・整列】の4原則を理解し、実践することが基本かつ最重要ですし、これらの基本原則は、下記の記事にもあるようにデザインを学習する上で定番です。2-1. デザインの4つの基本原則を意識する | はじめてのデザイン　〜デザインの基本・考え方〜4つのデザイン原則とは、紙やWebなどの媒体を問わず、伝えたい情報をわかりやすく伝えるために必要なデザインの原則です。chot.design続きをみる","link":"https://note.com/meijin_garden/n/ne5b35250d515","isoDate":"2020-07-23T14:28:18.000Z","dateMiliSeconds":1595514498000,"authorName":"Meijin"},{"title":"ご主人様、小難しいDDDやクリーンアーキテクチャはお忘れになって、”削除しやすい設計”から始められてはいかが？","contentSnippet":"ある日夢の中で設計に詳しい悪役令嬢が現れてこんなことを言い放ったので、考察してみましたという設定のポエムです。問題提起ドメイン駆動設計、オニオンアーキテクチャ、クリーンアーキテクチャといった考え方はもちろん重要なものの、僕は難しく考えずに「削除しやすいように機能を作る」のが第一歩として重要ではないかと考えています。本記事では「削除しやすい設計」について持論を展開してみます。※議論のスコープはWebサービスに限定し、例示としてPHPのフレームワークであるLaravelを用います削除しやすいことがなぜ重要か一度開発した機能は、それで終わりではなく、改修、改善を繰り返し、そして場合によっては仕様が廃止されることがあります。機能の廃止に伴ってコードを削除するとき、もし既存のコードの依存関係が複雑で、簡単に削除できなかった場合は、フロントエンドのみ削除して、バックエンドのロジックを残したままにする、といった暫定対処を行うこともあるでしょう。こういった対応で要件を満たし続けた場合、徐々に新規機能の開発や、既存機能の改善に影響を及ぼします。既存のソースコードがどの機能で使われているのか不透明になることで、ソースコードの再利用がやりにくくなり開発工数が増加、加えて、使われていない可能性もあると開発者が認知することにより、使われていないと思って改修したら実は使われていた、という逆にハマってしまう事例も起きうるでしょう。それに、ライブラリや言語のバージョンアップといったメンテナンス工数も肥大化します。残念なことに、一度開発した機能が廃止されるというのはWebサービスではよくあることです。こういった背景から、改修しやすいように、改善しやすいようにという観点だけではなく、消しやすいように作るということを考えるのが重要ではないかと考えますし、実は、削除しやすいということが最も重要な設計要件といっても過言ではないのではとも思います。削除しやすいように作ることで何が嬉しいか前節の通り、削除しやすいようにコードを作ることで、機能の廃止時にほぼ全ての関連するコードを削除することが可能になります。そうすれば、常にソースコードを無駄に肥大化させることを防ぎ、メンテナンスのしやすさを向上できます。また、削除しやすいように作るということは、ソースコード間の依存関係に気を使うということになる、副次的に設計の改善効果をもたらすと思います。例えばドメイン駆動設計に則って開発しよう、というと人によって考え方が異なるケースが多いです。削除しやすいように作ろう、と言う標語は、それに比べればかなり明確な指針と言えるのではないでしょうか。※もちろんDDDを否定する意見では有りませんし、僕自身もDDDを愛用しています。ただ、DDDだけで全ての機能開発ができるわけではないですし、もっと明確な指針という意味でも本記事で提示する考え方を主張しています。削除しやすい設計を実践する弊社ではLaravelを使っているので、Laravel前提での解説となりますが、他のフレームワークにおいても応用ができると思います。前置きが大袈裟でしたが、実践する内容は至ってシンプルなものばかりです。それでは説明を始めます。Controllerは1クラス1メソッドにするControllerは1メソッドしか持たないように実装します。Laravelですと、__invoke メソッドを実装したControllerにすることで、1メソッドしか持たないことを強制できます。ルーティングファイル(routes/web.php等)でもXXXController@hogeではなく、XXXControllerだけで書けてシンプルです。一例として、ログイン処理を実行するControllerを示します。class SignInController extends Controller{    public function __invoke(LoginRequest $request, LoginUseCase $loginUseCase): UserAccountResource    {        // ログイン処理を行いユーザーアカウントを示すインスタンス$userを取得する。詳細は省略        // $user = $loginUseCase->execute(...        return new UserAccountResource($user);    }}Pros利点としては、本来の目的通り、機能削除時にクラスごと消せばいいので大変明確です。機能が増えてもControllerがFatになりにくい利点もあります。ログイン処理のControllerなんて基本1メソッドだから__invokeとしなくて良いのではという見解もあるかもしれませんが、例えば複数の種別のユーザーを扱っておりそれぞれログイン処理が異なる可能性などがあります。弊社では以前UserControllerといった粒度で命名したControllerに大量のユーザー関連の処理が詰め込まれ、各アクションメソッドが何をしたいのか分からなくなることが有りましたが、その心配も不要になります。ユースケース（またはサービスクラス）も1クラス1メソッドにするControllerと同様、よくあるサービスクラスも1クラス1メソッドにします。僕は統一した決まりとして、ユースケースはexecuteメソッドだけを持っており、コンストラクタでRepository等をインジェクションしています。Prosについても同様です。UserServiceといったサービス名で作ってしまうと、あらゆる処理が詰め込まれてしまい、機能削除時に削除漏れしてしまうことが発生します。あらゆる実装を統一したディレクトリ名の配下に置くLaravelの場合は、Controllerユースケース（サービスクラス）RepositoryEloquent Modelメールイベントとイベントリスナ通知コマンドテストコードといった各機能が、基本的にはLaravelが決めたディレクトリの下に置かれることが多いと思いますが、これらのnamespaceに含まれるディレクトリ名にできるだけ単語の統一を図ります。ある機能名が、SomeAwesomeとした場合、App\\Http\\Controllers\\SomeAwesome\\XXXControllerApp\\Domain\\SomeAwesome の下にユースケース、Repositoryを始めとするドメインロジックApp\\Mail\\SomeAwesomeの下にメールApp\\Events\\SomeAwesomeの下にイベント、同様にリスナも配置App\\Commands\\SomeAwesomeの下にコマンドといったように、Laravelの規律に従いつつ、機能別の単語に合ったnamespaceに置くようにしています。Prosまだ全ての機能に対しては実現できていませんが、実現できた機能は廃止するときに大変削除しやすかったです。補足全ての機能をApp\\Domain以下に置く方針も考えたのですが、Laravelの経験者が実装するときの学習コストが無駄に上がってしまうデメリットも鑑みて、Laravelに依存しない純粋なドメインロジックのみApp\\Domain以下に置くやり方で現状は進めています。このへんはFWとどう向き合うかによって異なります。補足2機能名の英語ですが、ユニーク性にこだわるあまり長い名前にするとタイピングがしんどいので、多少厳密な英訳でなくてもタイピングしやすい名前にするのがおすすめです。そもそも機能名なんて割と仕様の都合で変わりますし。（経験済み）フレームワークが提供するORMに機能に関する知識を渡さない続いてはWebアプリケーションフレームワークが往々にして提供しているORMに関する指針です。LaravelだとEloquent Modelが該当しますので、Eloquent Modelを例に話を進めます。RailsだとActive Record、TypeORMだとEntityが該当すると思います。削除しやすい設計をする上で重要なのは、データベースとやり取りするためのORMに機能に関する知識を渡さないことです。ORMのクラスは機能と独立したディレクトリに置く往々にしてこれらのクラスは、データベースのテーブルと1:1の関係性で作られます。しかし、例えばusersテーブルは様々な機能で利用されるテーブルでしょうから、SomeAwesomeディレクトリを切ってその下に置くのは不適切と考えるほうが自然です。そのため、Eloquent Modelに関しては機能名のディレクトリの下に置くルールを適用しません。シンプルにApp\\Modelsの下に置きます。ORMに機能に関する知識をもたせるとどうなるか例えば、Q&A機能を持ったサービスを開発しているとして、すでに質問したことのあるユーザーかどうかを判断するアクセサをモデルに実装したとします。LaravelではXXXAttributeというメソッドを生やすことでアクセサを定義できます（個人的には分かりにくいのであまり好きではな略）。public function getHasQuestionsAttribute(): bool {    return $this->questions->isNotEmpty();}これだけだと非常にシンプルですが、実際にはここに「誹謗中傷の含まれた質問だったため運営から非表示対応された質問は除く」といったドメイン知識が混ざってくるとしましょう。public function getHasQuestionsAttribute(): bool {    // 雑に書いているので動くかわかりませんが、一応これが動く前提で話を進めます    return $this->questions->where('is_hidden', false)->isNotEmpty();}この書き方ですとquestionsを取得した後Collectionのメソッドで絞っているのでパフォーマンス良くないですし、「運営が質問を非表示対応できる」機能の一部がここに現れてしまっており、今後この機能を廃止したときに削除漏れしてしまう可能性があります。このように、Eloquent Modelを使い回す前提の機能開発は、どこに機能の実装があるか不透明になってしまい、削除しにくくなる、または削除したと思っても消しきれておらずバグを誘発する可能性があります。機能ごとにデータを取得・保持・整形するクラスを用意するというわけで指針としては、前節におけるApp\\Domain\\SomeAwesomeといった機能別のnamespace以下に、各機能ごとのデータを取得・保持・整形するクラスを用意することになります。データの取得は機能ごとにRepositoryを作成します。同時に、データを保持するためのDTOを作成しておき、RepositoryはORMを使ってデータベースから値を取得するものの、戻り値としてはDTOを返すように実装します。（※ドメイン駆動設計のアプローチではここでのDTOがEntityだったりValueObjectと呼ばれていますが、ここではDTOと便宜上呼ぶことにします）弊社で組んでいる簡単なRepositoryで例を示すと下記の感じです。<?phpnamespace App\\Domain\\SomeAwesome\\Infrastructure;use App\\Domain\\SomeAwesome\\Domain\\Entity\\Teacher;use App\\Domain\\SomeAwesome\\Domain\\Repository\\TeacherRepositoryInterface;use App\\Models\\Teacher as TeacherModel;final class MySQLTeacherRepository implements TeacherRepositoryInterface{    public function find(int $userId): Teacher    {        $teacherData = TeacherModel::findOrFail($userId);        return Teacher::reconstructFromRepository(            $teacherData->id,            $teacherData->name        );    }}App\\Models\\Teacherを使ってデータを取得しているものの、Repositoryの返り値としてはTeacherというEntityになっていることがわかると思います。（※ここでのEntityはDDDにおけるEntityを指しますが、本記事では単にデータの入れ物と思っていただければ差し支えないです）機能の仕様は、EntityのreconstructFromRepositoryメソッド内で表現したり、このRepositoryで投げるSQLで表現します。いずれにせよ、Eloquent Model自体には何もメソッドが足されていないことがポイントです。クエリを実行するためのRepositoryという存在、およびデータを運ぶDTOを作成することによって、機能に依存した実装をORMから引き剥がすことができるという話でした。細かい機能でも気軽に1クラスに切り出す最後に書くのは、細かい機能でも気軽にクラスとして切り出すというものです。ここまでの話でも似たようなことを言ってきましたが、一応セクションとして用意しておきます。フォーマッタの例まずは、フォーマッタの実装について挙げます。弊社で以前、「生徒の学年表記を短縮して表示したい」という要件が来ました。「小学1年生、小学2年生、小学3年生」という配列を「小学1〜3年生」と表示してほしいという要件です。同じ条件が中学生、高校生にもあります。ただ実装するだけですと、API Resource内でprivateなメソッドを切って変換用の関数としたり、Eloquent ModelのAttributeとしてgetFormattedGradeAttributeなどを切っても良かったでしょう。しかしここでは、専用の、XXXXGradeFormatterというクラスを作成することにしました。そして、そのクラスはたった1つのpublicメソッドであるformatGradesToTextを持つようにしました。final class XXXXGradeFormatter{    /**     * 対象学年をテキスト形式にフォーマットする     *     * @param MasterGrade[] $grades     * @return string|null     */    public static function formatGradesToText(array $grades)    {Prosこうするとテストも書きやすくなりますし、もちろん、削除したいときはクラス名でIDEを使って依存を検索すればすぐにわかります。クラス名にXXXXとついているのは、機能の名前です。単にGrade Formatterという命名にすると、その機能以外で学年のフォーマットをしたいときに自動的に仕様が同じになります。そのときに仕様が同じとは限りませんし、そうなればリファクタしたらいい話です。最初から過度に使われることを想定するのは悪手が多いと思います。一応、テストの例を下記に示します。学年のデータしか用意しなくていいのでテストがスリムです。final class XXXXGradeFormatterTest extends SetUpUserDataTestCase{    /**     * @dataProvider dp__grade_patterns     */    public function testFormatGradesToTextTest($gradeNames, $expectText)    {        $grades = [];        //...中略        $this->assertEquals($expectText, XXXXGradeFormatter::formatGradesToText($grades));    }    public function dp__grade_patterns()    {        return [            [                ['小学2年生'],                '小学2年生',            ],            //...中略            [                ['小学1年生', '小学2年生', '小学4年生', '小学5年生', '小学6年生', '中学1年生', '中学2年生', '中学3年生', '高校1年生', '高校2年生', '高校浪人'],                '小学1・2、4〜6年生、中学1〜3年生、高校1・2年生、高校浪人',            ],            [                ['小学1年生', '小学2年生', '小学3年生', '小学5年生', '小学6年生', '中学1年生', '中学3年生', '中学浪人', '高校1年生', '高校2年生', '高校3年生', 'その他'],                '小学1〜3、5・6年生、中学1・3年生、中学浪人、高校1〜3年生、その他',            ],        ];    }}外部APIへのリクエストの例外部のAPIへのリクエストも、リクエストごとにクラスに切り出すのがよいです。弊社ではHeadless CMSのmicroCMSを使っており、基本はフロントエンドから呼び出すのですが、まれにバックエンドから呼ぶことがあります。外部APIへリクエストするとき、下記のようにAPIのパスを呼び出し側のクラスに直接書くのはアンチパターンです。        $response = (new Client())->get(            \"何かしらのAPIパス\",            [                'headers' => [                    'X-API-KEY' => '何かしらのAPIキー'                ],                'timeout' => 30            ]        );というのも、これが複数のクラスで使われるAPIだった場合、もしAPIが廃止になったり変更になったときの影響範囲が文字列検索でしか見つけられなくなるからです。下記のように専用のクラスに入れておくことで、IDEの依存を検索すれば見つけられるようになり、より手軽と言えます。    public function __construct(        GeneralArticleMicroCmsClient $generalArticleMicroCmsClient    )    {        $this->generalArticleMicroCmsClient = $generalArticleMicroCmsClient;    }// ...中略    $response = $this->gradeArticleMicroCmsClient->get();※本気で組むならRepositoryとしてインターフェースを作成して、裏でmicroCMSを使っていることを隠蔽したほうが良いと思います。マサカリ防止割と初心者のうちは次々とクラスを切るという発想が浮かばないものですが、切ってみるとテストも書きやすいし再利用も効く、そして削除するときも楽になるのでおすすめです。まとめ色々と削除しやすい設計について書いてみました。エンジニアの学習過程という観点でも、クラスやインターフェースを気軽にサクサク作るレベルになる前にDDDやクリーンアーキテクチャを学んでも理解が追いつかないんじゃないかなと思っているフシが有り、まずは機能別にクラスを分けていこうという標語はレベル差を吸収できて便利じゃないかなあと思ってます。クラスを次々に作っていくような方針になっているので、日に日にクラス名や変数名の命名の難しさと向き合うことになってきています。個人的にはクラス名などの中に、主語動詞目的語をどのように入れるべきかの明確な指針が欲しいです。。。誰か知っている方がいれば教えて下さい！ぜひTwitterもフォローお願いします！Web開発全般（AWS、Laravel、TypeScript、DDD、Firebase、GitHub Actions等々）についてゆるゆるとツイートしています。https://twitter.com/Meijin_garden","link":"https://qiita.com/mejileben/items/48473a572ec07cbaf65f","isoDate":"2020-07-14T09:31:53.000Z","dateMiliSeconds":1594719113000,"authorName":"Meijin"},{"title":"Lambda@EdgeでレスポンスにHTTPヘッダを付与するやつをGitHub Actionsで自動デプロイする","contentSnippet":"概要フロントにNuxt.jsを採用していると、npm run startするだけだとX-Frame-OptionsとかCSPとかx-xss-protectionといったヘッダがレスポンスに付与されないFastifyをNodeサーバーとして使っているのでそちらで頑張ってもよかったけど、せっかくAWSでCloudFront->ALB->Fargateな仕組みを使っているので、AWSで頑張ってみようと思ったLambda@Edgeを使って、Nuxtからのレスポンスにヘッダを付与するやつを組んだアプリケーションと連動して動いたほうがいいし、手動でデプロイする運用がしんどいと思ったので、GitHub ActionsでCLIベースの自動デプロイが組めるところまで持ってきたそれをやるがためにCloudFormationまで導入しててんやわんやした日本語文献がそんなになかったので、まとまりがないメモですが貼っておきます。Lambda@Edgeのソース内容下記ブログを参考にしました。CSPだけ模倣するわけにいかなかったので、配列ベースでドメインを管理してjoinする感じで組む改修はしました。http://blog.serverworks.co.jp/tech/2020/02/27/add-security-headers-lambda-edge-cloudfront/'use strict';exports.handler = (event, context, callback) => {  //Get contents of response  const cf = event.Records[0].cf  const request = cf.request  const response = cf.response;  const headers = response.headers;  //Set new headers  headers['strict-transport-security'] = [{    key: 'Strict-Transport-Security',    value: 'max-age=63072000; includeSubdomains; preload'  }];  headers['content-security-policy'] = [{    key: 'Content-Security-Policy',    // 配列ベースで管理する    value: `default-src ${CSPDefaultSrcList}; img-src * blob: data:; script-src ${CSPScriptSrcList}; style-src ${CSPStyleSrcList}; object-src 'none';`  }];  headers['x-content-type-options'] = [{key: 'X-Content-Type-Options', value: 'nosniff'}];  // getFrameOptionsはrequestを受け取って、iframe用のページだけDENYしなかったりする  headers['x-frame-options'] = [{key: 'X-Frame-Options', value: getFrameOptions(request)}];  headers['x-xss-protection'] = [{key: 'X-XSS-Protection', value: '1; mode=block'}];  headers['referrer-policy'] = [{key: 'Referrer-Policy', value: 'same-origin'}];  //Return modified response  callback(null, response);};// 以下略大まかな設計雑に説明すると、Lambda@Edgeをデプロイするには、ソースコードを更新するだけじゃなくて、紐付けているCloudFrontも一緒に更新する必要があるプロダクションコードと同じリポジトリに、awsディレクトリを切って、Lambda@Edgeのソースを配置CloudFrontとLambdaを作成するCloudFormationのyamlも置いておくDevelop/MasterマージしたときにGitHub Actionsが動いて、前述のyamlを使ってAWS CLIでデプロイするGitHub ActionsでAWS CLI動かすのは公式がアクションを出してくれているので簡単- name: Configure AWS credentials  uses: aws-actions/configure-aws-credentials@v1  with:    aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}    aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}    aws-region: ap-northeast-1組み方すでにCloudFrontは事前にコンソールで作っていたので、CloudFormerを使ってCloudFormationのymlにエクスポートしたCloudFormerは癖が強いけど、公式ドキュメントのやり方通りにできるCloudFront/Lambda@EdgeのCloudFormation自社の構成がバレるので一部だけ引用して貼る。同じyml内にLambdaとCloudFront両方書くAWSTemplateFormatVersion: 2010-09-09Transform: AWS::Serverless-2016-10-31Parameters:  AwsLambdaRole:    Type: String    Description: Names of existing Roles you want to add to the newly created Managed Policy#...中略...Resources:  AddSecurityHeaderToResponse:    Type: AWS::Serverless::Function    Properties:      CodeUri: AddSecurityHeaderToResponse/      Role: !Ref AwsLambdaRole      Runtime: nodejs12.x      Handler: index.handler      Timeout: 5      AutoPublishAlias: stg      AssumeRolePolicyDocument:        Version: \"2012-10-17\"        Statement:          - Effect: \"Allow\"            Action: \"sts:AssumeRole\"            Principal:              Service:                - \"lambda.amazonaws.com\"                - \"edgelambda.amazonaws.com\"# ...中略...  StagingCloudFront:    Type: 'AWS::CloudFront::Distribution'    Properties:# ...中略...        DefaultCacheBehavior:          LambdaFunctionAssociations:            - EventType: origin-response              LambdaFunctionARN: !Ref AddSecurityHeaderToResponse.VersionGitHub Actionsこんな感じでAWSのCLIコマンドを実行すればいい。環境変数は適宜。ifを使えるので環境変数を切り替えることで検証環境と本番環境で1ファイルで運用することができます。      - name: Deploy latest Lambda function        run: |          aws cloudformation package --template-file $AWS_STACK_FILE_NAME --output-template-file packaged.yaml --s3-bucket $BUCKET_NAME --region us-east-1        working-directory: ./aws/lambda_edge      - name: Update Cloudfront Distribution        run: |          aws cloudformation deploy --template-file packaged.yaml --stack-name $AWS_STACK_NAME --parameter-overrides MainStreamBackendAcm=$AWS_CERTIFICATE_ARN AwsLambdaRole=${{ secrets.AWS_LAMBDA_EDGE_ROLE }} --region us-east-1        working-directory: ./aws/lambda_edgeメリデメPros一旦CSP頑張ってみることにしたので、アプリケーションでドメイン追加したときに必ず（ほぼ）同期デプロイで出せるLambdaを使うとローカル開発ではヘッダーを付与するのができないので、せめて同一リポジトリにおいて意識できるNginxの設定ファイルの管理のほうが個人的に辛いのでそれしなくてよくなったのがよいNuxt以外のサービスを導入することになったとしても、CloudFrontのレイヤーでHTTPヘッダを担保しているとセキュリティ安心感あるCons普通にCloudFormationつらかったIAM権限で必要なのが多すぎて、リソースや権限を*使わないように頑張るのがつらかった別にインフラ全部をCloudFormationしたいわけじゃなかったのに、Lambda@Edgeをリリースする関係で使い始めてしまったので中途半端CloudFormationとか全く知らなかったので結構手間取りました。1日半くらい溶かしてしまったので、まあまあ大変な方でしたね。参考文献CloudFormerで現状のCloudFrontの値をとりあえず取得https://docs.aws.amazon.com/ja_jp/AWSCloudFormation/latest/UserGuide/cfn-using-cloudformer.htmlめっちゃβ版って感じのUXでしたCloudFormationでLambdaのデプロイhttps://qiita.com/ytaka95/items/5899c44c85e71fdc5273CloudFormationでLambda＠Edgeをデプロイする - QiitaCLIでCloudFormationをデプロイする公式Doc基本はpackageを動かしたあとにdeployコマンド。作成も更新も同じコマンドでいい。create-stack/update-stackとかあるけどdeployだけでオールOKっぽい　ref: https://stackoverflow.com/questions/49945531/aws-cloudformation-create-stack-vs-deployhttps://docs.aws.amazon.com/cli/latest/reference/cloudformation/package.htmlhttps://docs.aws.amazon.com/cli/latest/reference/cloudformation/deploy/index.htmlCloudFormationのyamlには外から引数を渡すことができるhttps://docs.aws.amazon.com/ja_jp/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html開発と本番で違うところがあるからこれで引数で渡せるようにして、GitHub Actionsのyamlで環境変数を使って使い分ける感じCloudFormationでCloudFrontをデプロイするhttps://docs.aws.amazon.com/ja_jp/AWSCloudFormation/latest/UserGuide/aws-properties-cloudfront-distribution-viewercertificate.html公式が出している、ちょっと古いけどサンプルになるやつhttps://github.com/awslabs/serverless-application-model/blob/master/examples/2016-10-31/lambda_edge/template.yamlCloudFormation deployコマンドを叩いたときに無言で落ちるけど実際は権限エラーだよってやつhttps://github.com/awslabs/serverless-application-model/issues/58あまり役に立たなかったけど足しにはなった公式のFAQhttps://aws.amazon.com/jp/premiumsupport/knowledge-center/cloudformation-template-validation/これも役に立たなかったけど一応見たhttps://docs.aws.amazon.com/ja_jp/AWSCloudFormation/latest/UserGuide/using-cfn-validate-template.htmlデプロイ時には専用のIAMユーザー作って権限を付けるコレが一番大変だった。疲れた。デプロイ用のIAM作って、手元でコマンドを叩いて権限不足で弾かれるのを延々と繰り返す。AWSの設定している時、いつも「最小限のポリシーにしてから、失敗したら必要な権限だけ足していく」をやっているんだけど、これ無限に時間溶かさないですか？玄人の方々はどうやって乗り切ってるんだ— 名人 | ㈱NoSchool CTO (@Meijin_garden) July 7, 2020 このへんとか見た。https://docs.aws.amazon.com/ja_jp/AmazonCloudFront/latest/DeveloperGuide/lambda-edge-permissions.htmlhttps://gist.github.com/stu-smith/7fec25367e1b83fb0709c708a704ff04以上です。よかったらTwitterフォローしてください〜https://twitter.com/Meijin_garden","link":"https://qiita.com/mejileben/items/6f1d272809d6b0ff1aad","isoDate":"2020-07-07T11:46:30.000Z","dateMiliSeconds":1594122390000,"authorName":"Meijin"},{"title":"ITが発展した現代人だからこそ感じる”退屈”に切り込む名著「暇と退屈の倫理学」が面白すぎた","contentSnippet":"こないだ「暇と退屈の倫理学」という本を読みました。めっちゃ面白かったので、概要とか感想を書いていきます。続きをみる","link":"https://note.com/meijin_garden/n/n15144f5f6138","isoDate":"2020-07-04T09:28:32.000Z","dateMiliSeconds":1593854912000,"authorName":"Meijin"},{"title":"Nuxt×TypeScriptで型安全にディレクトリ構造を統一したパンくずリストを実装する","contentSnippet":"概要Web開発において、パンくずリストを正しく設定することは、ディレクトリ構造を検索エンジンに伝える上で重要です。問題提起本記事で解決手段を提起する問題は、主に以下の2点です。【ディレクトリ構造の管理が複雑でミスが起きやすい】サイト内の多種多様なページでそれぞれパンくずリストを実装していると管理が煩雑になり、ディレクトリ構造が矛盾してしまうリスクが起こる【フロントエンドでSEO対策を実装するのは特に難しい】もともとSEOに関するロジックを他のロジックから切り離して管理するのはサーバーサイドでも苦労する点であったが、フロントエンドがSEOのmeta情報等の管理責務を負うようになると素のJSでは特に難しいといえる以下、順に説明します。ディレクトリ構造の管理が複雑でミスが起きやすいここでは例として、「プログラミング言語ごとにエンジニアが登録されているサイト」を考えます。TOP > JavaScript > 開発太郎さん言語ごとにエンジニアが登録されているため、このようなディレクトリ構造をしています。TOP > JavaScript > 開発太郎さん > [記事タイトル]実装時には、もちろん各ページにそれぞれパンくずリストをコーディングします。TOP > Webエンジニア > JavaScript > 開発太郎さんWeb系以外のエンジニアも扱うサイトになってきたので、JavaScriptの上の階層に「Webエンジニア」を追加したわけです。TOP > JavaScript > 開発太郎さん > [記事タイトル]こちらも修正しなければいけません。現実的には、ほとんどすべてのページのパンくずリストを修正する必要が出てくるでしょう。各エンジニアの下にぶらさがっていた全ページのパンくずリストの修正が必要です。このように、各ページのパンくずリストを別個で実装していた場合、親の階層の変更が「自動で」子ページに反映されないため、変更漏れのリスクや、確認工数の肥大化といった課題が起こります。親ページの階層構造が変わったときに子ページに自動的に反映されないことが問題と言えます。フロントエンドでSEO対策を実装するのは特に難しい※こちらの問題については個人的な感覚ですのでご了承ください。元来、たとえバックエンドであっても、SEO対策に関するロジック（meta情報、パンくずリスト、構造化マークアップ）を他のビジネスロジックから切り離して保守性を高めて管理するのは骨が折れる作業です。JavaScriptでは型安全にコードを書くことが難しい上に、どうしてもバックエンドでは当たり前に行われているようなDDDやクリーンアーキテクチャのような責務を分離するノウハウがまだ当たり前にはなっていない印象です。弊社でも、当初はasyncData/fetch内にゴリゴリとパンくずリストのロジックを記述する運用で回していたのですが、前述の管理の課題が浮上したため、ロジックを切り出し、TypeScriptで型定義し、単体テストも書けて、パンくずリストのディレクトリ構造が統一できるようなクラス設計を導入しました。ディレクトリ構造を意識したパンくずリストの実装パンくずリストの型定義まずは、各パンくずリストのアイテムの型定義を示します。export type BreadcrumbsItem = {  // 表示する文字  text: string  // aタグのtitle属性。SEOやa11yのために設定。  title?: string  // nuxt-linkのために設定  to: string | Location  // trueにするとリンクではなくなる  disabled?: boolean}これで各ページを示すアイテムを型定義します。例えばトップページを示すアイテム、JavaScriptが得意なエンジニア一覧ページを示すアイテム、といった感じです。ページごとのパンくずリストを表現する基底クラス続いて、ページごとのパンくずリストを表現するクラスの基底クラスを示します。トップページを示すアイテムJavaScriptが得意なエンジニア一覧ページを示すアイテムエンジニアプロフィールページを示すアイテムを組み合わせることで、あるページのパンくずリストを実現します。組み合わせを実現する基底クラスを作り、それを継承することで各ページのパンくずリストを実現する手法を採用しました。BreadcrumbsBuilderはこちらです。export abstract class BreadcrumbsBuilder {  breadcrumbsItems: BreadcrumbsItem[] = []  parentBuilder: BreadcrumbsBuilder | null = null  parent (builder: BreadcrumbsBuilder) {    this.parentBuilder = builder    return this  }  push (item: BreadcrumbsItem) {    this.mainBreadcrumbsItems.push(item)    return this  }  getBreadcrumbs (): BreadcrumbsItem[] {    if (!this.parentBuilder) {      return this.breadcrumbsItems    }    return this.parentBuilder      .getBreadcrumbs()      .concat(this.breadcrumbsItems)  }}1つ目のポイントは、breadcrumbsItemsとしてBreadcrumbsItemの配列を保持していることです。前述の通り、一つのページのパンくずリストには、複数のアイテムが含まれているのでこのように保持します。2つ目のポイントは、あるページの親を示すパンくずリストをparentBuilderとして保持していることです。このように、あるページは自分自身のページのアイテムと、親のBreadcrumbsBuilderのみを保持する事によって、問題提起の節で例示した、「親ページの階層構造が変わったときに子ページに自動的に反映されない」問題を解消します。ページごとのパンくずリストを表現する拡張クラス実際にどのようにこの基底クラスを拡張するか見ていきましょう。export class TopPage extends BreadcrumbsBuilder {  constructor () {    super()    this.push({      text: 'エンジニアプロフィールサイトEnProfile',      to: '/',    })  }}コンストラクタにて、this.push を実行し、自身のページ、すなわちトップページのパンくずアイテムを設定します。これで終了です。export class EngineerListLanguage extends BreadcrumbsBuilder {  constructor (lang: Language) {    super()    this.parent(new TopPage()).push({      text: `${lang.name}`,      title: `${lang.name}が得意なエンジニア一覧`,      to: {        name: 'engineer-languages-langName',        params: {          langName: lang.name,        },      },    })  }}こちらの実装にて、「親ページの階層構造が変わったときに子ページに自動的に反映されない」問題を解消するロジックが少しずつ分かっていただけると思います。this.parent(new TopPage())こちらのparentメソッドの実行によって、JavaScriptが得意なエンジニア一覧ページの親ページがトップページであることを指定します。具体的に、トップページのパンくずリストがどのようなものか、知る必要はありません。改めて基底クラスを見直すと、parentメソッドの実装は以下のようになっています。  parent (builder: BreadcrumbsBuilder) {    this.parentBuilder = builder    return this  }parentBuilderに親を設定の上、thisを返すことでメソッドチェーンも可能にしています。続いてpushメソッドを実行して、自身のページについてもパンくずリストを保存します。    push({      text: `${lang.name}`,      title: `${lang.name}が得意なエンジニア一覧`,      to: {        name: 'engineer-langName',        params: {          langName: lang.name,        },      },    })最後に、各エンジニアのプロフィールページのパンくずリストを実装します。class EngineerProfile extends BreadcrumbsBuilder {  constructor (    engineer: Engineer,    lang: Language  ) {    super()    // 親を設定後、自分のページを設定する    this.parent(new EngineerListLanguage(lang)).push({      text: engineer.name + 'さん',      to: {        name: 'engineer-id',        params: {          id: `${engineer.user_id}`,        },      },    })  }}このように、エンジニアのプロフィールページの実装時には、その直接の親が言語別のエンジニアの一覧であることが確定しているだけで、さらにその親がどんなページなのかを知らなくていいようになっています。こうすることで、問題提起の節で例示した、「Web系以外のエンジニアも扱うサイトになってきたので、JavaScriptの上の階層に「Webエンジニア」を追加した」というケースでも、プロフィールページやそれ以下の層のページでは改修が不要で、自動的に親の親のページがパンくずリストに追加されることになります。パンくずリストのレンダリング以上にて、パンくずリストそのもののデータは一つのクラス内にディレクトリ構造を意識した上で格納することができたわけなので、実際にパンくずリストをレンダリングする処理にも言及します。asyncData内で実行します。※Nuxt2.12以降ならfetch内でthis.$XXXで実行します。          // これより前の処理でAPIからEngineer型のデータとLanguage型のデータを取得済み。          app.$setBreadcrumbs(            new EngineerProfile({              engineer,              lang            })          )便宜上、appオブジェクトからパンくずリスト設定用のメソッドを呼べると便利なので、下記のようにinjectしておきます。inject('setBreadcrumbs', (builder: BreadcrumbsBuilder) => {  store.commit(    'meta/setBreadcrumbs',    builder.getBreadcrumbs()  )}実装している処理としては、Storeのメタ情報設定用のmutationを呼んでいます。injectを間に噛ませておけば、Store以外の実装方法への移行コストが下がり、リファクタがしやすくなるという考えです。さて、パンくずリストComponentはlayout/default.vue にてIncludeされており、その内部実装は以下のようなTemplateで実装します。itemsという変数が、Storeからパンくずリストを取り出して設定されているPropsです。<template lang=\"pug\">nav  v-breadcrumbs(:items=\"items\")    template(v-slot:item=\"props\")      v-breadcrumbs-item(        active-class=\"\"        :disabled=\"props.item.disabled\"        :title=\"props.item.title ? props.item.title : props.item.text\"      )        span(:class=\"{ disabled: props.item.disabled }\") {{ props.item.text }}    template(v-slot:divider)      v-icon(size=\"18\") {{ icons.mdiChevronRight }}</template>テストコードテストコードを実装するときは、パンくずリスト自体がVueやNuxtになんの依存もないクラスとして独立しているため、jestであればシンプルにクラスを生成したと、ts-auto-mock でEngineerやLanguageのMockを作ってクラスのインスタンスに渡し、getBreadcrumbs()を実行して内容をチェックすればいいです。雑に書きますと下記のような感じですね。// @see https://typescript-tdd.github.io/ts-auto-mock/create-mockimport { createMock } from 'ts-auto-mock'// 略describe('正常系', () => {  const mockEngineer = createMock<Engineer>({    name: 'test',  })  const mockLanguage = createMock<Language>({    name: 'javascript',  })  const breadcrumbs = new EngineerProfile(mockEngineer, mockLanguage).getBreadcrumbs()  it('パンくずのアイテム数が意図したとおりであること', async () => {    expect(breadcrumbs.length).toBe(3)  })  // 以下、親パンくずの内容やタイトルについてExpectationしていく})以上まで、ディレクトリ構造を統一したパンくずリストの実装と、それをNuxt.jsにてレンダリングする実装例を提示しました。JSON-LDこちらは本題からずれるので詳細は割愛します（別記事で気が向いたら書きます）が、JSON-LDも、BreadcrumbsItem型の変数を駆使して生成します。nuxt-jsonldというライブラリと、schema-dtsというJSON-LDの型定義ライブラリを併用すれば、JSON-LDまで一気通貫で型安全の恩恵を受けながら構築できます。例示した実装内容の問題点ここまでお話したパンくずリストの実装内容は、実際に弊サービスにて運用されています。toメンバ変数がVueRouterのLocationになっているできればVueやNuxtから完全に独立した仕組みにしたかったのですが、成り行きでtoの型にLocationが含まれてしまいました。Locationに対して$router.resolve().hrefでstringに変換するアダプタを別で定義してあげて、パンくずリストのクラスを初期化するときなどにそれを間に噛ませるといった実装にしてtoにはあくまでstringしか渡らないようにすることをやってみたいです。子階層になればなるほどパンくずリストに必要なデータ数が増えるエンジニアプロフィールページを生成するときに、直接関係ない親ページに必要なLanguage型のデータが必要となっているように、これは更に深い階層のページになればなるほど、祖先の代で必要とするすべてのデータを渡さなければならないことを意味します。TypeScriptの構造的な型定義を活用すれば子ページの都合に応じて親に必要なデータを柔軟に渡すことは可能です。※つまり、親ページで利用を想定しているAPIを必ず子ページでCallしなければならないということではない現実問題パフォーマンスを考えればAPI呼び出しはPage Componentに統一して管理したいので、なんともいえません。なんか抽象クラスで頑張っているのがTSっぽくないこれは個人的な感覚ですｗいっそnuxt-ts-breadcrumbsみたいな名前でnpmライブラリとして公開できるくらい抽象化できないのかなんかできそうな気がするので、余裕があればやってみようと思います。npmライブラリの公開、やったことがないので良い機会でもありそうです。まとめ自身の親のみを参照する、という設計指針でパンくずリストのクラスを作成することで、ディレクトリ構造を統一したパンくずリストを実現することができました。","link":"https://qiita.com/mejileben/items/411910c332953907b1e5","isoDate":"2020-06-14T11:03:50.000Z","dateMiliSeconds":1592132630000,"authorName":"Meijin"},{"title":"「ZOOMと全く同じ機能をwordpressで実装した時の概算見積もり下さい」発言にできるだけツッコミを入れてみた","contentSnippet":"出社したら「ZOOMと全く同じ機能をwordpressで実装した時の概算見積もり下さい」って怪文書が置いてあったので会社爆破したというツイートがバズっていました。続きをみる","link":"https://note.com/meijin_garden/n/n6a3e866b3827","isoDate":"2020-06-05T03:03:41.000Z","dateMiliSeconds":1591326221000,"authorName":"Meijin"},{"title":"Laravelでメールを送るときに$messageという変数を使ったら「htmlspecialchars() expects parameter 1 to be string, object given」というエラーが出る","contentSnippet":"もはやタイトルの通りなのですが、何度も引っかかるので備忘録としてメモっておきます。環境Laravel6系※5系を利用していたときも同じエラーを踏んだ記憶があります挙動1：Mailableを継承したクラスでprivateなメンバ変数$messageを持っていると表題のエラーが出る    private $message;    public function __construct(UserDto $userDTO, string $message)    {        $this->userDTO = $userDTO;        $this->message = $message;    }    ...中略...    /**     * Build the message.     *     * @return $this     */    public function build()    {        return $this->subject('タイトル')            ->to($this->userDTO)            ->view('emails.sample.notified')            ->with(['user_name' => $this->userDTO->name, 'message' => $this->message]);    }まあ、上記のようなメール送信を行うクラスがあったとしましょう。これを利用してメール送信を実行するとlocal.ERROR: htmlspecialchars() expects parameter 1 to be string, object given (View: /app/packages/resources/views/emails/sample/notified.blade.php) {\"userId\":XXXX,\"exception\":\"[object] (ErrorException(code: 0): htmlspecialchars() expects parameter 1 to be string, object given (View: /app/packages/resources/views/emails/sample/notified.blade.php) at /app/packages/vendor/laravel/framework/src/Illuminate/Support/helpers.php:251)[stacktrace]というエラーが出ます。挙動2:$messageをpublicに変えると、何もエラーが出ないがメールも送られなくなるこちらももっと謎なのですが、    public $messageのように修飾子を変更すると、エラーも出なくなりますがメールも送られなくなります。いよいよ謎です。対策withの変数名を変えると動きます。例えばbodyなどに変更します。クラスのmessageプロパティの命名や修飾子は変えなくていいです。            ->with(['user_name' => $this->userDTO->name, 'body' => $this->message]);原因はわからない追記コメントの方でこれが原因では、という推測をいただきましたので、原因が気になる方はコメントをご参照ください。軽く追ってみたのですがさっぱりわかりません。ただ、Mailableクラスのここはちょっと怪しいなと感じました。Mailable.phpL297        foreach ((new ReflectionClass($this))->getProperties(ReflectionProperty::IS_PUBLIC) as $property) {            if ($property->getDeclaringClass()->getName() !== self::class) {                $data[$property->getName()] = $property->getValue($this);            }        }ReflectionClassを使って自クラスのpublicなプロパティを一覧で取得しており、それを$dataに入れているので、ここで'message'という名前がカニバってしまっており、もともと期待されていた挙動をしなくなったのではないかと類推しました（そこから、挙動2のように修飾子を変える実験に至った）。が、もうちょっと追わないとわからないです。あと、2020年5月現在のLaravel最新ソースが、僕の手元のソースから若干変更が入っており、現在は治っている可能性は一応あります。https://github.com/laravel/framework/blob/7.x/src/Illuminate/Mail/Mailable.php所感この挙動に基づいたIssueとか見当たらなかったのですが、自社のなんらかの他のソースが影響しているのかなぁ・・・Mailableはそのまま使っているのでありえないとは思うのですが。","link":"https://qiita.com/mejileben/items/078e03c41bb9cbe13ba7","isoDate":"2020-05-30T07:30:03.000Z","dateMiliSeconds":1590823803000,"authorName":"Meijin"},{"title":"25歳になったので、24歳の1年間の活動レポートを書いてみます","contentSnippet":"今日2020年5月8日で、25歳になりました。せっかくなので、1年間の振り返りも兼ねて、活動レポート的なのをまとめてみます。続きをみる","link":"https://note.com/meijin_garden/n/n135662c83c47","isoDate":"2020-05-08T11:55:20.000Z","dateMiliSeconds":1588938920000,"authorName":"Meijin"},{"title":"Nuxt.js×TypeScriptで自社製バックエンドとmicroCMSバックエンドを型安全に併用するTips","contentSnippet":"概要前回の記事で、TypeScriptで利用しているバックエンドのAPIを型定義して利用する方法を紹介しました。今回はその応用編です。APIの型定義とは？aspidaとは？という方は前記事をご覧ください。APIを型定義することで、APIから返ってくる値は本来any型になってしまうところを、APIのパスと戻り値の型をaspidaで紐付けることで型安全にAPIを扱えます。本記事では、最近流行のヘッドレスCMSであるmicroCMSと、自社製のバックエンドAPIを併用している場合に、両方型安全に扱う方法を説明します。microCMSを例に挙げますが、microCMS以外のヘッドレスCMSを活用する際にもご利用いただけるTipsです。microCMSについてmicroCMSは、簡単に言えばデータを入稿すればそれをGET/POSTできるAPIが自動で作られるサービスです。個人利用でも無料で10個のAPIまで作成できるので、興味を持った方は利用を始めてみると良いでしょう。APIが提供されるのがポイントで、例えばFirebaseであればFirebaseのSDKを入れないとデータを取ったりできないのに対して、APIのためクライアントは任意のライブラリを選定できます。JavaScriptですとfetchでもaxiosでもkyでもいいですし、弊社のようにネイティブアプリをリリースしている場合でも導入コストはほぼゼロです。課題microCMSを導入する場合、入稿されるデータは様々な形式になるため、管理が必要でしょう。弊社の場合、SEO目的のブログコンテンツに始まり、ユーザー向けの通知文章なども入稿しています。また、microCMSの場合はAPI KEYがアクセスに必要なので、全体で共通のaxiosインスタンスを使う必要がありますが、既に既存で自社製のバックエンドAPIを利用しているので、別途別のaxiosインスタンスを用意する必要があり、オレオレ設計になってしまう危険性があります。まとめると以下のとおりです。APIのパスと、入稿データの管理が必要既存のバックエンドとは別のaxiosインスタンスが必要解決策これらの課題に対しても、前記事で紹介したaspidaを活用することで解消できます。aspidaをnpm installのうえで、下記のように設定ファイルを記述します。~/plugins/apiClient.tsimport { Plugin } from '@nuxt/types'import axiosClient from '@aspida/axios'import axios from 'axios'import api, { ApiInstance } from '@/apis/$api'import microApi, { ApiInstance as MicroApiInstance } from '@/apisMicrocms/$api'declare module 'vue/types/vue' {  interface Vue {    $api: ApiInstance    $microcms: MicroApiInstance  }}declare module '@nuxt/types/app' {  interface NuxtAppOptions {    $api: ApiInstance    $microcms: MicroApiInstance  }}declare module 'vuex/types/index' {  interface Store<S> {    $api: ApiInstance    $microcms: MicroApiInstance  }}const plugin: Plugin = function ({ $axios }, inject) {  inject('api', api(axiosClient($axios)))  inject(    'microcms',    microApi(      axiosClient(axios, {        baseURL: 'https://HOGEHOGE.microcms.io/api/v1',        headers: { 'X-API-KEY': process.env.MICROCMS_GET_API_KEY },      })    )  )}export default pluginaspida自体は下記の2行でセットアップが完了しますが、Nuxtで使うためにinjectする必要と、Context等のオブジェクトに対して型を定義する必要があります。import api, { ApiInstance } from '@/apis/$api'api(axiosClient($axios)) // これでaspidaを利用できるインスタンスが生成できるまた、今回は複数バックエンドを利用するので、ルートディレクトリにaspida.config.jsを置きます(Docs)。~/aspida.config.jsmodule.exports = [  { input: 'apis' },  { input: 'apisMicrocms' },]上記のセットアップが完了していれば、Vueファイルからは下記実装によってmicroCMSからデータを取ることができます。▼APIの型定義~/apisMicrocms/general-article/index.tsimport { MicroCmsArticle, MicroCmsRequest } from '../type'export interface Methods {  get: {    query: MicroCmsRequest    resBody: { contents: MicroCmsArticle[] }  }}~/apisMicrocms/type.tsexport type MicroCmsArticle = {  id: string  // サムネ  image_url: {    url: string  }  createdAt: string  updatedAt: string} & MicroCmsArticleCntentexport type MicroCmsArticleCntent = {  title: string  description: string  body: string}export type MicroCmsText = {  text: string}export type MicroCmsRequest = {  // fieldsのtypoを防ぐために文字列リテラル型にする。随時増やす  fields?: 'id,title,description,image_url'  limit?: number  filters?: string}▼Vueファイルsample.vue  async fetch () {    this.articles = (await this.$microcms.general_article.$get({      query: {        fields: 'id,title,description,image_url',        limit: 1000,      },    })).contents  },aspidaの基本的な利用方法は、予め設定ファイルで指定したディレクトリ（ここでは~/apisと~/apisMicrocms）以下に型定義ファイルをTypeScriptで書き、npx aspidaを実行すると良いです。僕はmicroCMSで書かれるデータの大半がブログ記事であることに着目し、apisMicrocms/type.tsに基本的なブログ返り値の型を定義しています。GET時のクエリパラメータも型定義できます。microCMSで作成されるAPIは割と独自の検索クエリを仕様として持っており、たとえば?fields=id,title,description,image_urlのようなクエリによって、戻ってくる値を絞り込むことができます。GraphQLに近い世界観ですね。それらの検索パラメータもMicroCmsRequestとしてまとめておきます。microCMSの検索クエリの形式はできるかぎり覚えたくないので、エディタの補完で効くのに越したことはないからです。下記のように、VSCodeで型補完が効いていることも確認できます。以下の例では記事一覧が取得できていますね。Veturを併用することでtemplateタグ内でも補完を効かせることができました。課題解決の確認さて、以上の実装で冒頭に示した課題が解決できたかどうかを確かめてみましょう。APIのパスと、入稿データの管理が必要既存のバックエンドとは別のaxiosインスタンスが必要APIのパスと入稿データの管理はaspidaに設定したことで終わっており、型が効くのでtypoしたり忘れるリスクはありません。また、APIのパスが変更になっても関連する利用箇所がすべてコンパイルエラーで落ちます。既存のバックエンドとは別のaxiosを利用するのも、pluginsでAPI_KEY等を設定した別のインスタンスをInjectすることで問題なく利用できます。補足上記のようなプロダクトコードですと、microCMSから別サービスに移行したときの変更範囲が甚大になるため、Repositoryパターンを利用するなりして、microCMSを利用していることはVueからは意識しなくていいようにするのが理想ではあります。弊社では手抜きで実装してしまっています。まとめぜひAPI型定義ライブラリのaspidaを活用し、型安全に自社製バックエンドとmicroCMSの併用をしましょう。","link":"https://qiita.com/mejileben/items/6b15d91995927a8df262","isoDate":"2020-05-07T01:01:32.000Z","dateMiliSeconds":1588813292000,"authorName":"Meijin"},{"title":"現時点でWebエンジニアとしてできることを書き出してみた【AWS編】（2020年5月）","contentSnippet":"こんにちは。株式会社NoSchoolでCTOをしている名人です。普段ベンチャー企業でほぼ自分1人で開発しているので、自分の技術を客観視する機会がありません。ということで、自分ができること、これからの課題をまとめる機会を作ってみました！続きをみる","link":"https://note.com/meijin_garden/n/ne331031753da","isoDate":"2020-05-01T00:57:16.000Z","dateMiliSeconds":1588294636000,"authorName":"Meijin"},{"title":"フロントエンドで始める「API の型定義」のススメ(Nuxt×TS×aspida)","contentSnippet":"概要本記事では、Nuxt.js のプロジェクトに TypeScript を導入するにあたって、バックエンドの API を型定義することで API 呼び出しにも型付けの恩恵を受けられる方法を示します。本記事の通りに API を型定義すると、API のレスポンスだけでなく、Path も TypeScript で定義できます。これにより、レスポンスを型安全に扱えますし、API の Path が変更された時にコンパイルエラーで変更箇所を検知できるといったメリットを享受できます。API の型定義はライブラリの導入によって実現できます。Nuxt.js を例に説明しますが、他のフロントエンドにも導入しやすいはずなので、ぜひご活用ください。本記事の流れはじめに既存実装の問題点を提示し、そのあとライブラリの導入によって API を型定義した結果を示します。問題点が解消できることを確認し、具体的な導入手順を補足します。随所に弊社で僕が実際に感じている課題、実際に運用して解決できそうな課題についても補足することで、実運用へのヒントを示します。ソリューションはライブラリの導入なので、導入方法等はライブラリの README が適切であることから、僕の記事では問題点の提起と実運用に関して論述するところに厚みを持たせます。How To が気になる方は途中で示すライブラリの GitHub へ飛んでもらえればと思います。既存実装の問題点一例として、下記のように@nuxtjs/axiosを用いて API を叩いている事例を示します(※)。const userResponse = await this.$axios.$get(\"/api/v1/contents/\" + params.id);このコードが抱えている課題として以下があります。API の Path をベタ打ちしているので、typo しても気づかないAPI の仕様が変わったとき、Grep して当該 API を使っている場所を探さないといけない返り値の型がわからない。せっかく TypeScript を使っているのに any になってしまう(特に TypeScript で書いている場合)Path のベタ打ちや、返り値が any になるのは axios のみならず fetch や ky を使っていたとしても当然とも思われますが、これらの課題を API の型定義によって解消できる、というのが本記事の主眼です。※)独自の axios ラッパーを定義してエラーハンドリング等を共通化する事例もありますが、本記事では axios をそのまま使っている例を出しました弊社の状況ここで、せっかくなので、自社で導入した背景を補足として説明します。Nuxt.js に TypeScript を導入したのは Nuxt.js で構成したサイトをリリースしておよそ半年経過してからでした。導入の際、主な懸念（TS を導入してもさほど効果が上がらないリスク）はVuex の型付けTemplate 内の型付けREST API の型付けでした。Vuex についてはほとんど使用しないようにしていて、ユーザーのステート管理くらいでしたので、vuex-module-decoratorsを導入して少し実装を調整すると終わりました。Template 内の型付けも、（導入当時はまだ機能不足の感がありましたが）VSCode の Vetur プラグインで補完や null 判定等もかなり DX を保って行えるため、そこの懸念も小さかったです。ただ問題は REST API との通信で、GET した値が any になるなら as で型定義することになるでしょうし、POST/PUT 時に投げる値については都度 Body の内容を型定義しても、他のページで同じ API に POST するときに Body に型定義することを強制できないです。（ちょっと乱暴な例ですが）下記のように僕が実装したとして、await this.$axios.$put(`/api/users/${id}`, {  title: \"hogehoge\",  body: \"hogehoge\",} as UserAccount);他のメンバーが同じ API を型付けせずに実装しても、コンパイルエラーしないため、運用でカバー、レビューでカバーみたいに風化することが予想できますね。await this.$axios.$put(  `/api/users/${id}`,  {    tilte: \"hogehoge\",    boby: \"hogehoge\",  } // 型付けしなくても別に通るし、なんなら上のtitle, bodyがtypoしているけどコンパイルエラーしないですね);TypeScript API Type Definitionといった単語でググっても全然ヒットしないので(※)、一般的なライブラリのような形に落とし込まれたソリューションは無いのかなと思っていた、というところまでが弊社の状況でした。※)ある程度のエキスパートであれば、もしかすると各プロジェクトに応じて何かしらの解決策、例えば API の Path と渡す Body の型定義を辞書のようにした巨大なオブジェクトを使って Repository を構成するようなことをやってのけているかもしれませんが、そこまで頑張るのなら TypeScript やらなくていいかな・・・と思っていました。API を型定義するとどうなるかそれではここまでの前提を踏まえて、API を型定義することで問題点を解消していけることを説明していきます。ライブラリの概要API を型定義するには aspida(アスピーダ)というライブラリを使います。国産のライブラリ、というか、普通に都内のフロントエンドの勉強会に登壇されているような方が 2019 年末に立ち上げたプロジェクトであるため、気軽に作者に連絡や改善要望できる点は嬉しいポイントです。ここまでの話で、気になって仕方なくなった＆ある程度 README 読んだらわかりそうだって方は以下のリポジトリを見てください。https://github.com/aspidajs/aspidaAPI を型定義したあとの世界それでは aspida を導入することで実装内容がどのように変わり、どのような利点を享受できるのかを説明していきます。実装内容が変わることまずは実装で変わることを説明します。以下の既存実装のソースコードがあるとします。先程例示したように、API の Path をベタ打ちで、リクエストの Body は無理やり型定義しています。await this.$axios.$put(`/api/users/${this.$route.params.id}`, {  title: \"hogehoge\",  body: \"hogehoge\",} as UserAccount);aspida を導入し、API の型定義をした後は下記のように書けます。await this.$api.users._id(this.$route.params.id).$put({  data: {    title: \"hogehoge\",    body: \"hogehoge\",  },});見た目の観点で変わっていることとしてはAPI の Path を文字列ベタ書きではなく、オブジェクトのプロパティをネストして表現している$axiosではなく$apiという別のクライアントを使っているといったところです。続いて、このように実装内容が変わることで、どのような利点があるのかを実装時、運用面の両方から整理します。実装時に得をすることもし API の Path を typo すると、コンパイルエラーになるaspida で API を定義すると、API の Path がオブジェクトのプロパティとして表現されます。したがって、例えば/api/usersの users を user を打ち間違えるとコンパイルエラーになります。PUT する Body の内容を typo してもコンパイルエラーになる同様に、渡すリクエストボディも予め型定義された状態で扱えます。例えば title を tilte に打ち間違えるとコンパイルエラーになります。運用時に得をすることAPI を誰が使ってもリクエストボディ、レスポンスボディの内容を型定義できる解説は省略しましたが、レスポンスボディも型定義した状態で扱えます。aspida の記法で API を扱っている全エンジニアが、型の恩恵を受けた状態で開発ができます。API の仕様変更時に追従していない実装をコンパイルエラーで気づくことができるAPI を仕様変更したとき、例えばPOST を PUT に変えたuser を users に変えたリクエストボディの内容が変わったレスポンスの内容が変わったといった場合、aspida 上で型定義した内容を書き換えると、対応した実装がすべてコンパイルエラーになります。このあと、実際の導入手順を示した上で、コンパイルエラーで検知できる例を示しますので、合わせてご覧ください。導入方法それでは実際の導入手順を示していきます。詳しくはリポジトリの README を見てください。大まかには下記の手順で実施します。aspida の npm installapis ディレクトリを作成し、なにか一つ API を型定義してaspida --build$api オブジェクトを$axiosを元に Wrap し、Vue インスタンスと Nuxt.js コンテキストに Inject するnpm installaspida は 2020 年 3 月現在、axios、ky、fetch を Wrap して型定義機能のついた HTTP クライアントに変換することができます。ここでは axios を Wrap する前提で説明します。また、すでに@nuxtjs/axiosを利用していることも前提です。していない場合は別途、素の axios をインストールしてください。npm install @aspida/axiosapis ディレクトリを作成し、なにか一つ API を型定義してaspida --buildここが aspida の最大の特色です。apis ディレクトリをルートディレクトリに作成したら、そこから API の Path の構造と同じ構造でディレクトリを作成します。/api/v1/users/${userId}という API を作成したい場合は、apis/v1/users/_userId@number.tsにその API の型定義を記載します(※)。実際の型定義の方法は README をご覧ください。しかし、ここで型定義を書いたとしても、最終形ではthis.$api.hogehoge.hogehoge....という形で利用できることから、$apiオブジェクトを生成する必要があります。それをやってくれるのがaspida --buildコマンドです。/apisディレクトリの中のディレクトリ構造から、自動で API の型定義ファイルを生成してくれます。package.json{  \"scripts\": {    \"api:build\": \"aspida --build\"  }}※)$axiosのほうで、BASE_URL を設定していれば、$axiosを Wrap するクライアントを作るのが aspida なので/apiディレクトリを作成する必要はありません。$api オブジェクトを$axiosを元に Wrap し、Vue インスタンスと Nuxt.js コンテキストに Inject するaspida --buildコマンドが行うことの実態は、/apis/$api.tsに自分が定義した API をすべて吐き出すことです。実際に出力された内容を読むと理解しやすいと思います。続いて、これらを Nuxt.js Component で利用する必要があるので、inject します。/plugins/apiClient.tsimport { Plugin } from '@nuxt/types'import `axios` Client from '@aspida/axios'import api, { ApiInstance } from '@/apis/$api'declare module 'vue/types/vue' {  interface Vue {    $api: ApiInstance  }}declare module '@nuxt/types/app' {  interface NuxtAppOptions {    $api: ApiInstance  }}declare module 'vuex/types/index' {  interface Store<S> {    $api: ApiInstance  }}const plugin: Plugin = ({ $axios }, inject) => {  inject('api', api(axiosClient($axios)))}export default plugin最後のapi(axiosClient($axios))がポイントで、@nuxtjs/axiosを aspida が用意している Wrap メソッドのaxiosClient()を実行することで Wrap オブジェクトを生成し、その結果を inject しています。弊社の場合だと、$axios 自体に BASEURL の設定などをすでに終わらせていたので、設定内容がそのまま aspida にも適用できたのが便利ポイントです。こうすることで、API の Path がディレクトリに基づいてオブジェクトのプロパティのネストで表現できるようになり、例えば返り値のAxiosResponseも型定義ファイルで定義した型を扱えるように Wrap されます。コンポーネントで使ってみるコンポーネントで使うときはthis.$apiまたはcontext.$apiで利用できます。エディタで実際に書いてみると、以降の API の内容がプロパティになっているので補完されていくことが確認できるでしょう。以降は、バックエンドエンジニアから API の仕様を聞いたら aspida の書き方に落とし込んで型定義ファイルを自動生成し、実装していくのを繰り返します。注意点一度勘違いされたことがあるのですが、型定義自体をミスってしまうことは防げません（そもそも TypeScript がそうですからね）。titleを間違ってnumberと定義してしまうと、実行時エラーが起きる原因になります。利点の検証さて、実際に aspida を導入する内容を説明したところで、上記で示した API の型定義の利点を検証してみましょう。ここでは、API の仕様変更時に追従していない実装をコンパイルエラーで気づくことができるを検証してみます。API の仕様変更でコンパイルエラーになる実際の事例実際に弊社のソースコードで、POST /user/registerというユーザー登録の API があるのですが、これをPOST /usersという RESTful な API に書き換えてみます。やるべきことは以下の 2 つです。/apis/user/register/index.tsの内容を/apis/users/index.tsにコピーaspida --buildを実行その瞬間、npm run devを実行しているコンソールが動き出し、下記のようなエラーが出ます。 ERROR  ERROR in /Users/.../signup.vue(87,53):87:53 Property 'register' does not exist on type '{}'.    85 |   methods: {    86 |     async submit (params: RegisterBody) {  > 87 |       const registerResponse = await this.$api.user.register       |                                                     ^    88 |         .$post({    89 |           data: {    90 |             email: params.email,このように、API の仕様を変えたとき、既存実装が Type Error を吐いてくれるので、移行すべき実装に気がつくことができます。API を容赦なく仕様変更したり削除できるかどうかは長期的に見て大きなメリットがあるはずです。特に弊社はほとんど Web 開発を僕 1 人でやっているようなベンチャーですが、PMF するまでの改善プロセスでプロダクトを作っては捨てていくことが多く、aspida のように容赦なく捨てられるような工夫を仕込んでおくことにメリットを感じています。導入にあたっての注意点などライブラリの成熟度aspida自体は始まったばかりのライブラリなので、破壊的な仕様変更が発生する可能性があります（2020 年 3 月現在、まだメジャーバージョンが 0）。弊社のように小回りがきくベンチャーなら導入しやすいですが、タイトな現場ではまだ様子見したほうがいいかもしれません。逆に、作者の方は Twitter 等でも活動していたり discord でコミュニティを作っているので、改善要望等の連絡はつきやすいということが利点としてあげられます。僕は破壊的変更があったときにアップデートタイプする際、めっちゃ DM で質問攻めにさせていただきましたｗhttps://twitter.com/m_mitsuhideまとめAPI の型定義自体は応用範囲が非常に広く、backend が strapi や microCMS、Firebase の REST API で作られています、という場合にも応用できると考えられます。告知僕の会社ではオンライン家庭教師に特化したマッチングサービス NoSchool(https://noschool.asia/ )を運営しています。親御さんは生徒にどんな教育を受けさせていいかわからない、家庭教師側は個人で活動していても集客がままならない、といった双方の課題をどうやって解決していくかを考えつつ、Zoom 等の普及に伴ってオンライン家庭教師市場そのものを大きくしていこうというベンチャーです。https://twitter.com/Meijin_garden","link":"https://qiita.com/mejileben/items/11f206a51861bb404e1a","isoDate":"2020-03-23T02:15:15.000Z","dateMiliSeconds":1584929715000,"authorName":"Meijin"},{"title":"【PHPUnit】モックした関数の返り値を引数を元に求めるにはandReturnUsingを使う","contentSnippet":"背景PHPUnit を使っていると、関数をモックにしたい場面があります。Mockery::mock('class name')->shouldReceive('method')->withArgs($param)->andReturn($returnValue);こういった書き方では返り値が決め打ちになっています。andReturnUsingを利用するありました。andReturnUsingという関数を使えばいいです。書き方はコールバックを受け取り、コールバックの引数をモック化したい関数の引数と同じにします。returnするだけで返り値を指定できます。Mockery::mock('class name')    ->shouldReceive('method')    ->withArgs(function ($params1, $params2) {        // $paramsを使った処理・・・        return true;    })    ->andReturnUsing(function ($params1, $params2) {        // $paramsを使った処理・・・        return $calculateResult;    });実例ユースケースの中で、別のエンドポイントに通信して、得た結果で引き続き処理をするというものがありました。この場合は通信自体モックにするのがベターですが、どうしても通信先の処理も結合テストしたかったので、まとめてテストできるようにテストを書きました。$clientMock = Mockery::mock(Client::class);$clientMock->shouldReceive('post')    ->withArgs(function (string $uri, array $data) {        // 省略        return true;    })->andReturnUsing(function (string $uri, array $data) {        $response = $this->post('{テストしたいエンドポイント}', $data['form_params']);        $mock = Mockery::mock('TestResponse');        // GuzzleのResponse Interfaceをモック        $mock->shouldReceive('getStatusCode')->andReturn(200);        $mock->shouldReceive('getBody')->andReturn(json_encode($response->json()));        return $mock;    });$this->app->instance(Client::class, $clientMock);こうすると、andReturnUsingの中で、$this->postで実際の通信処理が走るので、別のエンドポイントの動作チェックも兼ねることができます。また、引数で$data['form_params']を渡すことで、引数が正しく渡っていることがテストできます。繰り返しますが、本当はこういった場合は個別にテストを書いたほうがいいですね。","link":"https://qiita.com/mejileben/items/436a5ea0065e2bb638c8","isoDate":"2020-03-12T09:43:29.000Z","dateMiliSeconds":1584006209000,"authorName":"Meijin"},{"title":"Nuxt+SSR+TypeScript なアプリケーションを GitHub Actions で GAE に自動デプロイする","contentSnippet":"対象読者Nuxt.js で SSR したときのお手軽デプロイ方法を知りたいGoogle App Engine(GAE) に Nuxt をデプロイしたいGitHub Actions で GAE に自動デプロイしたい概要Nuxt.js のデプロイ先に悩むことが多く、特に SSR した場合に手軽にデプロイできる方法を探していました。静的サイトなら Netlify で十分なのですが、SSR だったり、動的にコンテンツが増える状況において、Netlify では役不足です。でも、mater merge 時の自動デプロイとカスタムドメインはありがたい存在なので、他のデプロイ先に移行しつつ、Netlify のメリットを受け継げる方法を探しました。調査の結果、GAE への Nuxt.js のデプロイによって、自動デプロイとカスタムドメインの要件も含めすべて満たすことができました。GCP と GAE の設定まずは GCP および、 GAE の初期設定について解説し、その後デプロイ方法について、最後に GitHub Actions について説明していきます。gcloud コマンドのインストール自身の PC に、下記ページを参考に gcloud コマンドをインストールします(※MacOS の場合)。https://cloud.google.com/sdk/docs/quickstart-macos?hl=jaインストール後は PATH を通しておくと便利です。GCP Project の作成続いてデプロイ先になる GCP のプロジェクトを作ります。今回の場合、僕が作ってみたサービスでは Firebase を利用しているので、対応する GCP プロジェクトはすでに作られていました。GCP プロジェクトが作成できたら、課金を有効にしておきます。そのあと、gcloud initコマンドを実行して、作成した GCP プロジェクトを利用できる状態にします。app.yaml の設置続いて、GAE の設定ファイルであるapp.yamlをプロジェクトルートに設置します。以下のような内容で作成します。とりあえずこれで動いていますが、Node.js のバージョン、および静的ファイルやインスタンスの大きさなどは適宜調整してください。公式ドキュメントはこちらruntime: nodejs12instance_class: F2handlers:  - url: /_nuxt    static_dir: .nuxt/dist/client    secure: always  - url: /(.*\\.(gif|png|jpg|ico|txt))$    static_files: static/\\1    upload: static/.*\\.(gif|png|jpg|ico|txt)$    secure: always  - url: /.*    script: auto    secure: alwaysenv_variables:  HOST: \"0.0.0.0\"  NODE_ENV: \"production\"Nuxt.js アプリケーションの作成とビルドアプリケーションの作成今回は Nuxt.js （バージョン 2.9 以降）で TypeScript を利用しており、かつ、nuxt.config.js などの設定ファイルも TypeScript 対応しているものとします。僕は 2.10.2 と 2.11.0 でデプロイできることを確認済みです。また、SSR 対応している前提なので、mode: 'spa'ではありません。nuxt.config.tsimport { Configuration } from '@nuxt/types'const config: Configuration = {    ...package.json のビルドコマンドも nuxt-ts を利用しています。\"build\": \"nuxt-ts build\",ビルドローカルでnpm run buildを実行してビルドが通る状態にしておきます。$ npm run build...ce849990709e675b2f0d.js    7.4 KiB      13  [emitted] [immutable]e1e7424856593dd60cc8.js   20.1 KiB       8  [emitted] [immutable]  pages/indexef4de0a4edcd2c1e3068.js   7.49 KiB       0  [emitted] [immutable]              server.js   32.6 KiB       2  [emitted]              app   server.manifest.json  899 bytes          [emitted]Entrypoint app = server.jsGAE への Nuxt アプリケーションのデプロイとカスタムドメインビルドが通ったら、続いてgcloud app deployコマンドを実行します。$ gcloud app deploy --project={プロジェクト名}最初のデプロイはファイル数が多いので案外時間がかかります。また、途中で yes/no をプロンプトで訊かれるので、忘れず yes を入力しましょう。デプロイ後エラーになったとき僕の記憶ではデプロイ自体に失敗したことはなかったはずですが、デプロイ後にページを開くとエラーになる場合があります。基本的にはエラーの原因になったライブラリをdevDependenciesからdependenciesに移行すれば解決しました。@nuxtjs/style-resourcesや@nuxt/typescript-buildが最初devDependenciesに入っていたので、実行時にエラーを起こしていました。package.jsonを編集し、再度npm run buildからやり直すことで、動作しました。この時点で、https://{プロジェクトID}.appspot.comでページを開くことができるはずです。デプロイした環境にカスタムドメインを設定するGAE にはカスタムドメインを紐付けることができます。僕は AWS の Route53 で日頃ドメインを取っているので、今回も Route53 で取得したものを紐付けました。こだわりがなければ Google Domain で取得したほうが取り回しはいいかもしれません。概ね、下記記事の通りで紐付けできました。https://consulting.blog.rakumo.com/entry/20180109/customdomainGitHub Actions を設定し、master merge したときに自動でデプロイ以上で、手動でデプロイすることは可能になったので、次は master merge したときにデプロイを実現します。GitHub Actions 自体は、リポジトリ内に.github/workflows/gcloud.ymlといった名称のファイルを置いてリモートに Push するだけで設定可能です。GitHub の Actions タブからポチポチするだけで、勝手に yml が置かれて、Feature ブランチに Push されるので本当にすぐ設定は終わります。問題は yml の中身です。僕は下記の yml で動作しました。.github/workflows/gcloud.ymlname: Google App Engine Deployon:  push:    branches:      - masterjobs:  build:    runs-on: ubuntu-latest    strategy:      matrix:        node-version: [12.11.0]    steps:      - uses: actions/checkout@v2      - name: Setup gcloud environment        uses: GoogleCloudPlatform/github-actions@0.1.1        with:          # The version of the gcloud SDK to be installed.  Example: 275.0.0          # The service account email which will be used for authentication.          service_account_email: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_EMAIL }}          # The service account key which will be used for authentication.          service_account_key: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_CREDENTIALS }}      - name: Run tests with ${{ matrix.node-version }}        uses: actions/setup-node@v1        with:          node-version: ${{ matrix.node-version }}      - name: npm install, build        run: |          npm install          npm run build        env:          APIKEY: ${{ secrets.FIREBASE_APIKEY }}          AUTHDOMAIN: ${{ secrets.FIREBASE_AUTHDOMAIN }}          DATABASEURL: ${{ secrets.FIREBASE_DATABASEURL }}          PROJECTID: ${{ secrets.FIREBASE_PROJECTID }}          STORAGEBUCKET: ${{ secrets.FIREBASE_STORAGEBUCKET }}          MESSAGINGSENDERID: ${{ secrets.FIREBASE_MESSAGINGSENDERID }}          APPID: ${{ secrets.FIREBASE_APPID }}          MEASUREMENTID: ${{ secrets.FIREBASE_MEASUREMENTID }}      - name: GAE deploy        run: gcloud app deploy app.yaml --project {プロジェクト名}ポイント上記の yml を作成するためのポイントはいくつかあります。on push で master ブランチを指定するmaster merge したときにデプロイしたいので、動作するトリガーは master への Push とします。GoogleCloudPlatform/github-actions を利用する公式がサービスアカウントのクレデンシャルなどを読み取ることを前提とした設定を公開してくれているので、ありがたく利用します。サービスアカウントの作成サービスアカウントを GCP コンソールから作成します。これは、GitHub Actions にデプロイ権限を渡すために必要な作業です。GitHub Actions は第三者のアプリケーションになるので、そこからデプロイを実行するためには適切な権限が必要なので、その権限を付与したサービスアカウントを作成し、そのクレデンシャルを GitHub の Secrets に設定のうえ、yml で読み取るという流れです。GCP のコンソールから IAM→Service Accounts へアクセスします。画面内の「＋サービスアカウントを作成」ボタンを押し、サービスアカウント名には「GitHub Actions」等の命名をつけます。また、作成後は、下記の権限を付与します。僕は下記の権限を付与したところで無事にデプロイができるようになりましたが、過不足あればぜひおしえてください。できれば思考停止で管理者権限付与などはしたくないものです。サービスアカウントの作成時に、キー（クレデンシャル）の作成ができるところがあるので、これをクリックし、JSON 形式でダウンロードしてください。以上でサービスアカウントの作成が終わりです。キーは base64 エンコードするさて、https://github.com/GoogleCloudPlatform/github-actions/tree/master/setup-gcloud に記してあることですが、上記でダウンロードしたクレデンシャルの JSON ファイルは、Base64 エンコードしたうえで GitHub の Secrets に保存します。ローカルで base64 コマンドを叩くなどしてエンコードしてください。service_account_key: (Optional) The service account key which will be used for authentication. This key should be created, encoded as a Base64 string (eg. cat my-key.json | base64 on macOS), and stored as a secret.GitHub Secrets 設定GitHub の Setting タブから、Secrets 画面に移動し、上記の yml ファイルに指定されている「GOOGLE_SERVICE_ACCOUNT_CREDENTIALS」などの環境変数を保存していってください。僕がやっていたプロジェクトでは Firebase を利用しているので、Firebase 関連の情報も全部 Secrets に載せました。以上で設定は終わりです。実際に master merge してみると、Actions タブからデプロイが動いていることを確認できますし、もし失敗してもログが出ているので、だいたいなんとかなると思います。補足ERROR: (gcloud.app.deploy) Error Response: [7] Access Not Configured. Cloud Build has not been used in project XXXXXXX before or it is disabled.というエラーがデプロイ時に出たら、その後に表示されているリンクをクリックしてCode Buildを有効にしてください。まとめ最後の GitHub Actions の設定がもっとも難しいところですが、一度やってしまえば、SSR 対応の Nuxt アプリケーションを master merge 時に自動デプロイでき、しかもカスタムドメインで SSL 対応も終わっているので大変便利だと思います。簡単な用途であれば、SSR 対応のアプリケーションで Netlify とほとんど近しい DX を再現できたと思います。","link":"https://qiita.com/mejileben/items/eaa125c18fd80e15f2db","isoDate":"2020-02-24T04:22:59.000Z","dateMiliSeconds":1582518179000,"authorName":"Meijin"},{"title":"LaravelのModelに補完が効かなくて辛い人たちに贈る「Laravel IDE Helper Generator」の紹介","contentSnippet":"Eloquent Model でプロパティや scope を扱うときに補完が効いて欲しい。しかし、例えば下記のようにコードを書いても補完が効かなくて辛いですよね。SampleRepository.php    $sample = new Sample();    dd($sample->id); // ここでidに補完が効いて欲しい！できればタイプヒンティングもしてほしい！このように Model からカラム名にアクセスした際に補完が効かないのに加え、クエリをカプセル化してくれる scope を利用したときも補完は効きません。App\\Models\\Sample.php    public function scopeIsPublic($query)    {        return $query->where('is_public', true);    }SampleRepository.php    $sample = new Sample();    dd($sample->isPublic()->get()); // ここでisPublic()に補完が効いて欲しい！補完が効かないから、カラム名は typo や型を間違えて代入してしまうリスクもあるし、scope も大文字や小文字を間違えてしまうこともあるでしょう。本記事では Laravel の Model に補完・型情報を付与してくれるライブラリ【Laravel IDE Helper Generator】について解説します。本記事でできるようになることこのように scope を hover すると型定義が出ますし、補完も効きます。また、カラム名へのアクセスに対しては型補完が効いています（業務ソースなので隠しまくりなのですがご容赦ください）。この例ですと、とあるテーブルの transferred_at カラムへ日付を保存しているわけですが、日付保存可能かつ、振り込みされていない場合は null が格納されている、といったことがある程度型情報から読み取ることができます（null が良いのかはさておき）。セットアップhttps://github.com/barryvdh/laravel-ide-helperに概ね書いてあるとおりです。まずは composer でインストールします。composer require --dev barryvdh/laravel-ide-helperLaravel5.5 以上を利用している方はこれでセットアップはもう終わりです。Model の phpDocs を自動生成続いて Model の scope やカラム名に対応した phpDocs を自動生成します。下記コマンドを実行します。php artisan ide-helper:model --nowriteide-helper:modelコマンドで実行できるわけですが、型定義ファイルをつくるオプションと、各 Model に直接上書きするオプションがあります。個人的には、自動生成されたコメントがプロダクトコードに入り込むのは、運用ルールが増えてしまってあまり好きではないので--nowriteオプションをつけて実行するのがおすすめです。さて、コマンド実行後に、root ディレクトリに_ide_helper_models.phpが生成されています。一部抜粋するとこのような内容です。_ide_helper_models.php/** * App\\Models\\User * * @property int $id * @property string|null $email * ...以上でやることはもう終わりました。さっそく自身の Repository や Model ファイルを開き、hover してみましょう。補足運用面では_ide_helper_models.phpを git 管理してしまうと、複数メンバー間で Conflict が多発すると思うので、gitignore 扱いにして、各自で生成しましょうという運用にしたほうが望ましいと思います。","link":"https://qiita.com/mejileben/items/a01f03d203ead8cb7081","isoDate":"2020-02-18T08:40:16.000Z","dateMiliSeconds":1582015216000,"authorName":"Meijin"},{"title":"僕が「クチコミ」に対して抱く違和感と、その違和感に対処するための仮説","contentSnippet":"ECサイトや、レストランの予約サイトなど、購買行動を伴うWebサイトやアプリには、おおよそ決まって「クチコミ」が存在する。かのGoogle Mapsにさえも、場所に対してクチコミを投稿することができる機能がある。続きをみる","link":"https://note.com/meijin_garden/n/n4fe60b5d102a","isoDate":"2020-02-11T08:23:26.000Z","dateMiliSeconds":1581409406000,"authorName":"Meijin"},{"title":"LaravelをPHPUnitとPostman でテストする手法まとめ（Passport にも対応）","contentSnippet":"Laravel で開発されているプロダクトにおいてテストコードを書く方法を、 PHPUnit および Postman を主体にしてまとめます。テスト作成の背景弊社（株式会社 NoSchool）では、Web フロントエンドに Nuxt を利用しており、また、iOS ネイティブアプリも開発しているため、Laravel を原則 API ベースで開発することが多いです。API のテストを作成することは、バグのリスクを低減したり、アプリエンジニアとの仕様の共有のために必須となります。2020 年 1 月現在 NoSchool では PHPUnit および Postman を利用していますので、ドキュメントを兼ねてまとめました。この記事を読むとわかること  PHPUnit を使って API 単位でのテストを書く方法  PHPUnit を使って Class 単位での単体テストを書く方法  Postman を使って API のレスポンスをテストする方法  それぞれの比較と、実運用する際に共存する方法環境  Laravel 5.7(古い...)  PHPUnit 7.0  Mockery 1.2PHPUnit概要PHPUnit は、PHP のコードベースでテストを記述できるフレームワークです。PHPUnit でテストを書く目的PHP のコードベースのため、データベースのサンプルデータを柔軟に生成し、テスト後に破棄すると言ったことが可能になります。そのため、細かいテストケースを実装するのに向いています。書き方ディレクトリ構造弊社ではtestsディレクトリ以下に下記のディレクトリ構造でテストを書いていますので、参考までに。./Feature 結合テスト（API テスト）を書きます。HTTP のエンドポイント単位でのテストを書きます。API を開発したときは原則必須で対応するテストコードを実装しましょう。./Unit 単体テストを書きます。クラス単位でのテストを書きますが、工数が多くかかること、設計変更に追従するコスト、および Final Class をモック化できない Mockery の制限などの理由から、あまり実装されることはありません。Rendering まで Laravel で行っている一部ページや、クラス単位でのテストをどうしても書きたい場合はこちらに書きます。./Fixture テスト用のデータを書きます。アプリ経由の課金で Apple から送信されるレシートなど、細かいデータを表現するときに使います。./Lib 複数のテストケースの基底となるクラスなどを格納します。各テストコードの基本各テストコードは、それぞれのディレクトリ以下にドメインごとに namespace を切って作成してください。また、命名は ◯◯Test.php で作成してください。ex. ./Feature/Chat/RoomTest.phpまた、各テストケースはTests\\TestCaseクラスを継承してください。final class RoomTest extends TestCase各テストケースの基本各テストケースは、test◯◯ という名称の関数で作成します。use Tests\\TestCase;final class RoomTest extends TestCase{    protected function setUp() // 後述    {        parent::setUp();    }    public function testSendMessage()    {        // hogehoge    }API テスト一つのテストケースの中で、下記のようなフェーズを順に実行します。  テストデータの準備  API リクエストの実行  レスポンスのステータス、Body のテスト  必要に応じて、変化したデータベースの中身のテストテストデータの準備一般に、各テストケースにおけるテストデータの準備は、setUp()メソッドにて実装します。setUp()は各テストケースの実行直前に呼ばれます。反対に、終わったあとに呼ばれるのはtearDown()です。こちらはデータの後始末などに利用します。    protected function setUp()    {        parent::setUp();        $this->room = factory(Room::class)->create([            'user_id' => 1111        ]);    }ここでのポイントは大きく 2 点あります。まず、parent::setUp()を実行することです。これを実行することで、Laravel アプリケーションを動かすための初期設定が終わります。実行しない場合、例えばconfig()を使った実装等が動かないので必ず実行してください。詳しい実装は/Illuminate/Foundation/Testing/TestCase.phpに書いてあります。2 つめのポイントはfactory()グローバルヘルパを利用してテストデータを生成することです。ファクトリはdatabase/factories以下に作成します。詳しい書き方は実際のコードを読んだり、公式ドキュメントを参照してください。ここで重要なのは以下の 2 点です。  factory を create するタイミングでテストデータを Array で渡すことで上書きできる  factory 自体に名前をつけることができるため、例えば同じ User Model に対する factory でも違う初期データを持ったインスタンスを作り分けることができるファクトリ生成後は、実データがデータベースにインサートされているため、それがある前提で以降のテストを書くことができます。【補足】テストデータの削除テストデータを毎回テストのたびに生成していると、データベースがテストデータで溢れかえってしまいます。ここで、DatabaseTransactionsを利用することで当該テストにて作成されたデータは全てテスト終了後に削除されます。use Illuminate\\Foundation\\Testing\\DatabaseTransactions;class RoomTest extends TestCase{    use DatabaseTransactions;API リクエストの実行API リクエストは下記のように実行します。リクエストするメソッドには複数ありますが、個人的にはjsonメソッドが好きです。$response = $this->json(    'PUT',    \"/api/chat/{$this->room->id}\",    [        'body' => 'message    ],    $headers)【補足】Laravel Passport を利用している場合Passport を使っていると、都度都度 API リクエストに特定のヘッダを指定しなければなりません。具体的には、Bearerトークンが必要です。これを解消するための手段を公開してくれている Web ページが有りましたので、ご参照ください。大まかに言えば、setUp()を拡張してそこでUserに対応したアクセストークンを都度都度発行しています。https://www.whizz-tech.co.jp/1442/こうすることで、json()実行時の第 4 引数にヘッダーでBearerを渡せば認証済みユーザーとしてテストが実行できます。また、弊社のネイティブアプリ向けの API の場合、ログアウトユーザーでもクライアント単位でのグラントトークンを Bearer に載せることを必須としているのですが、そのトークンもsetUp()を使って実装できます。/oauth/tokenへ POST を飛ばしてトークンを都度発行すればいいです。補足： https://laravel.com/docs/5.7/passport#testing に書かれているactingAsを使った実装は何故か動きませんでした【補足】Cookie 認証の API を利用している場合Cookie 認証の API を利用していて、かつ認証済みのユーザーで API をリクエストしたいときはactingAsメソッドを利用します。$response = $this->actingAs($user)    ->json('PUT', '/api/room', [    ]);factory(User::class)->create()でテストユーザーを作成後、そのユーザーで認証された状態で API を叩いた場合のテストなどをするときに有効です。レスポンスのステータス、Body のテストレスポンスのステータスは、下記のようにテストします。$response->assertStatus(204);レスポンスの Body は、下記のようにテストします。$response->assertJson([    'message_id' => 100]);この場合のテストは一例で、具体的な値をテストできるものから、JSON の構造のみテストするものまで色々あります。assertJsonはかなりゆるく、指定したキーを持ってさえいれば、余分なキーが含まれていてもエラーになりません（第 2 引数でより strict にできるようです）。ここでどうテストするかはテストケースで何をしたいかによるでしょう。ただ、特にネイティブアプリへのレスポンスなど、型にまで気を使わなければいけない場合において、下記のように構造とそれぞれの持っている型を見ることになると思います。$response->assertJsonStructure([    'id',    'user' => [        'id',        'name',    ],    'created_at',]);$this->assertIsInt($response->json('id'));$this->assertIsInt($response->json('created_at'));$this->assertIsInt($response->json('user.id'));$this->assertIsString($response->json('user.name'));ネストしているキーに、Laravel にあるあるのドット記法でアクセスできるのは便利ですね。詳しくは公式情報をどうぞ。https://laravel.com/api/5.7/Illuminate/Foundation/Testing/TestResponse.htmlhttps://phpunit.readthedocs.io/ja/latest/assertions.html#assertisint必要に応じて、変化したデータベースの中身のテスト副作用のある API であれば、データベースに変更をもたらすでしょう。データベースの中身をテストする場合は下記のように記述します。$this->assertEquals(    3,    Room::where('body', 'hogehoge')->count());https://readouble.com/laravel/5.7/ja/database-testing.html を見る限り、assertDatabaseHasというメソッドも用意されています。しかし、この場合はカウントで 2 つ以上のものがあること、というのは確認できませんので、用途に応じて使い分けてください。このように Eloquent Model を使ってクエリを発行して結果をチェックというのは少々我ながら筋が悪いため、より上手に書ける方法を知っている方は教えていただけると嬉しいです。単体テスト単体テストは、前述したとおり結構モック化を頑張らないと厳密な単体テストの実現が難しいです。もし実装したい場合は、下記のようなコツを念頭に実装してみてください。ここではユースケース層のテストを例に話します。NoSchool の場合、ユースケース層からは Repository の Interface を呼んでおり、AppServiceProviderで実装クラスにbindingしているという特徴を持っているため、その前提での解説となります。DI を使っている場合はresolveヘルパでインスタンスを取得DI している場合は普通にコンストラクタを書けないはずなので、resolveヘルパでインスタンスを取得し、そこからメソッドを実行してテストします。$sendChatMessageUseCase = resolve(SendChatMessageUseCase::class);テストしたいクラス内で使っている外部クラスを Mock にしたい場合、DI するのが一番確実っぽい以下の例はユースケースで使っている Repository をモック化した例です。$repository = Mockery::mock(new MemberRepository($this->user));$repository->shouldReceive('findMember')->once()->andReturn(    $member);$repository->shouldReceive('createMember')->once()->andReturn($member);$this->app->instance(    'App\\Infrastructure\\MemberRepository',    $repository);final クラスをモック化するときはalias:記法を使うfinal なクラスをモックにするときはalias:を先頭につけて namespace を記述します。なんじゃこりゃ。まあ、そもそも final なクラスをモックにする意味あるのかって話なのですが。$requestStub = \\Mockery::mock('alias:App\\Helpers\\HttpClient');といったややこしい仕様が散見されるので、特にfinalなクラスを使うのをやめるか、\\Mockeryを使った単体テストはあまり書かないようにするか、というのが工数的なデメリットを鑑みると妥当かなというのが感想です。より良いライブラリや、Mockery でももっと楽に書けるぞ、という情報提供お待ちしております。テストの実行テストの実行は、./vendor/bin/phpunitコマンドで実行します。ディレクトリをオペランドに指定することも、ファイルを指定することも、何も指定せずに全てをテストすることも可能です。[mejileben]$ ./vendor/bin/phpunit ./tests/Feature/Room上記のコマンドでは、Roomディレクトリ以下のテストケースを全て実行します。コマンドを覚えたくない方は、composerやartisanコマンドとしてエイリアスを貼ってもいいでしょう。Postman概要Postman は、API のドキュメントを書いたり、テストケースを書いてまとめて複数の API をテストできるサービスです。Swagger のテスト実行機能がついたようなイメージです。Swagger を使ったことがないのでイメージですが。Postman を導入する目的Postman を導入することで、API ドキュメントをネイティブアプリエンジニアに Web 経由で共有することができます。NoSchool では API 定義を JSON でエクスポートし、Git 管理しています。これを各自が Import することで API 定義を確認できます。有料プランに加入することで複数人が Web 上で共有を完結できるそうですが、ケチっているのでまだ無料プランです。Postman 環境設定の概要詳しくは割愛しますが、主に以下の点に注意が必要です。  秘匿情報は Environment として管理し、GitHub には上げない。または暗号化する  ローカル環境で HTTPS を利用しているとき、設定画面から SSL のチェックを無効化しないとオレオレ証明書でエラーを吐いてしまうPostman を使った API テストのしかたPostman で API 定義を作成し、試しに「Send」ボタンを押すと、レスポンスが返ってきます。ここまで終わったら、「Tests」タブを開き、下記のようにテストを書いていきます。var jsonData = pm.response.json();pm.test(\"id is number\", function() {    pm.expect(jsonData.id).to.be.a(\"number\");});pm.test(\"room.id is 1540\", function() {    pm.expect(jsonData.room.id).to.eq(1540);});Postman のテストケースはJavaScriptのライブラリであるChaiを利用しているため、JavaScript ベースで書くことができます。まずjson()メソッドでレスポンスの JSON を取得します。次にpm.test()でテストケースを作成します。expect()でテストしたい値を JSON から抜き取り、その後は英文を書くかのようにメソッドチェーンで.to.be.aなどとつないでいき、最後に型名か具体的な値を書くことでテストが実行されます。ここでは.toや.beをつけることは必須ではないのですが、そのほうが英文っぽく書けるので好ましいと思っています。それだけです。Rspec 等と思想が似ていると思います。Postman のテストでは具体的な値等までテストすることは難しいので、基本的にレスポンスの型のみテストすることが大半です。Collection を作るさて、API テストをいくつか作成すると、Collection というものにまとめることができます。Collection は、例えば Q&A サイトの場合、「質問したあとに回答がつき、それをベストアンサーにする」といった複数の連続した API のテストをすることが可能です。テストを実行するテストの実行は、クライアントアプリケーション上からもできるし、CLI から Node.js 等のコマンドベースでも実行可能です。Postman を利用するメリットは？API テストの表現力という意味では PHPUnit で頑張るほうが身の丈に合ってそうですが、例えば検証環境など、HTTP 越しでアクセスしたい場合は Postman でリクエストの向き先を Localhost から検証環境に向けて実行することができるなど、手軽さという意味では Postman に軍配があがるイメージです。ただ、CI を組み込んだ場合などは結局 PHPUnit を検証環境で実行することなど簡単でしょうから、Postman でテストを頑張るメリットは薄れ、Swagger 等と同様で API の定義を複数の社員間で共有することがメイン目的となるでしょう。個人的には Passport を使っている環境でも PHPUnit ベースでテストできることが衝撃でした。先の記事を公開した方に感謝です。まとめPHPUnit も Postman も両方 API ベースでのテストの記述が可能ですが、PHPUnit のほうがより細かい制御が可能です。Postman は API 定義をまとめるのに特化して、PHPUnit でできる限りテストを書いていくのが 1 つの良い共存方法かと思います。","link":"https://qiita.com/mejileben/items/cbe0608ee43aa1fab258","isoDate":"2020-01-10T07:19:53.000Z","dateMiliSeconds":1578640793000,"authorName":"Meijin"},{"title":"Nuxt×vue-property-decoratorでvalidateメソッドを実装する","contentSnippet":"Nuxt×vue-property-decoratorでvalidateメソッドを実装する方法そんなにあり得ないパターンかなとは思いますが、個人開発で色々試しているときに引っかかった＆いい具合のGoogle検索結果が出なかったのでメモ程度に。@Componentデコレータ内に書く一言で言えば、@Componentデコレータに指定すればいいです。例えばこんな感じ.vue@Component({  components: {    Form: () => import('~/components/organisms/Form.vue'),  },  validate ({ params }) {    // 数値のカテゴリIDじゃないと404にする    return /^\\d+$/.test(params.categoryId)  },})export default class Post extends Vue {このように、@Componentデコレータ内に実装すればいいだけの話だったのですが、うっかりPostクラス内に書いてしまって動かずに困惑しました。雑感nuxt-property-decoratorも調べてみましたが、特段こちらがvalidateメソッドをサポートしているわけでもないんですね。","link":"https://qiita.com/mejileben/items/53248659153215303e41","isoDate":"2020-01-08T11:55:55.000Z","dateMiliSeconds":1578484555000,"authorName":"Meijin"},{"title":"2019年の緩すぎる振り返り 勝手に都内のおすすめ銭湯まとめ","contentSnippet":"真面目なノートを年の瀬に2本も書いて疲れたんで、緩いのを書きます。真面目なのが気になる方はこちらとこちらへ。続きをみる","link":"https://note.com/meijin_garden/n/n568e16734869","isoDate":"2019-12-31T13:52:18.000Z","dateMiliSeconds":1577800338000,"authorName":"Meijin"},{"title":"CTOとしてスタートアップに転職して9ヶ月で学んだこと\n（Redashで数値分析編）","contentSnippet":"こんにちは。株式会社NoSchoolでCTO（最高技術責任者）を務めている名人です。2019年3月に前職のLIFULLからNoSchoolに転職して9ヶ月が経ちました。年末なので、自身の振り返りをまとめます。続きをみる","link":"https://note.com/meijin_garden/n/ncf1c634dd909","isoDate":"2019-12-31T12:53:30.000Z","dateMiliSeconds":1577796810000,"authorName":"Meijin"},{"title":"CTOとしてスタートアップに転職して9ヶ月で学んだこと（技術編）","contentSnippet":"こんにちは。株式会社NoSchoolでCTO（最高技術責任者）を務めている名人です。2019年3月に前職のLIFULLからNoSchoolに転職して9ヶ月が経ちました。年末なので、自身の振り返りをまとめていこうと思います。続きをみる","link":"https://note.com/meijin_garden/n/n8fd8d1cb24b9","isoDate":"2019-12-31T09:34:59.000Z","dateMiliSeconds":1577784899000,"authorName":"Meijin"},{"title":"Laravelでドメイン駆動設計(DDD)を実践し、Eloquent Model依存の設計から脱却する","contentSnippet":"この記事はドメイン駆動設計#1 Advent Calendar 2019の 10 日目の記事です。2020/12/17追記以下に続編を書きました！LaravelにDDDを導入して1年経った所感(達成したこと / 課題点 / モデリングの難しさなど)やったこと自社サイトのバックエンドを Laravel で実装して半年間が経ち、初期に考えた設計にいろいろと綻びが出てきたと感じていました。Eloquent Model 依存の設計」の問題点を提起し、「DDD を取り入れて実装した結果」のソースコードや考え方、そのメリットを記載しています。結論Laravel の Model をあらゆるレイヤーで使うと改修が難しくなる開発する機能のユースケースを主語と述語で文章に表現し、そのまま UseCase 層の実装として表現するEntity や ValueObject に制約条件をまとめ、適切に例外を吐くLaravel の Model は ORM としてのみ利用するPHP の言語自体の限界はあるので、命名の工夫などで適宜我慢する実運用の際はどの機能から、どこまで完璧主義で DDD をやるか考える初期の設計まずは「もともと Laravel で実践していたEloquent Model 依存の設計」についてお話します。本記事で話題に上げるのは、私が勉強 Q&A サイトを開発していたときの話です。開発する上で意識すべきデータは「質問者・回答者」「質問」「回答」などです。Laravel の設計は、おおまかに下記の方針で行いました。テーブルごとに Laravel のModelを作成する（User、Question、Answer・・・）それぞれの Model を使ってデータを CRUD するRepositoryを作成する（UserRepository、QuestionRepository、AnswerRepository・・・）Repository からデータを取ってきたあと、サービスの仕様に合わせて整形する目的で、Serviceを作成する（UserService、QuestionService、AnswerService・・・）同様にControllerを作成する（UserController、QuestionController、AnswerController・・・）このように、あくまでテーブル構成を思い浮かべ、テーブル構成に対応した Model を作成し、以降 Repository、Service、Controller と、レイヤー化しているように見えるけど、実際はただ単にデータをリレーしているだけのアーキテクチャを組んでいました。Model の扱い例えば「質問を 1 件取得する」場合、下記の手順で実装します。① QuestionRepository に返り値としてQuestionModel を返す質問取得メソッドを実装public function findQuestion(int $id): Question{    return Question::findOrFail($id);}② 次に QuestionService にfindQuestion(int $id)を QuestionRepository のfindQuestionを読んで返すだけの内容で実装します。public function findQuestion(int $id): Question{    return $this->repository->findQuestion($id);}③ 最後に QuestionController を実装します。public function findQuestion(int $id){    return view('question.find', [        'question' => $this->service->findQuestion($id)    ]);}④ blade ファイルの中では\\$question を起点にデータをリレーションで取得して表示します。<h1 class=\"title-question\">  {{ $question->title }}</h1><span class=\"author-name\">{{ $question->user->name }}</span><span>さんの質問</span>@foreach ($answers as $question->answer)<section class=\"answer-item\">  ... 以降、質問の各回答が並ぶ ...</section>このように、【Eloquent Model を View まで返す】方法で実装しました。Model を View まで取り回すメリット何にせよ開発が非常に速いです。{{ $question->user->name }}というのは、Question.php に    public function user(): BelongsTo    {        return $this->belongsTo(User::class)->withDefault([            // ...        ]);    }のようにリレーションが設定されていれば、View 層で User が Question のプロパティかのように繋げてアクセスできるということを示しています。User にリレーションが設定されていれば、さらにそこから繋げてデータにアクセスできます。これはつまり、【View 層で新しいデータが欲しいときは、Model だけ変更すれば Repository、Service、Controller の変更が不要である】ことを示します。例えばあるとき、「質問一覧画面には質問本文の最初の 20 文字だけ表示して欲しい」という要件があったとしましょう。下記のように blade ファイルに直接 PHP のプログラムを書くのはちょっと憚られますよね（※str_limit_ja は全角文字ベースで文字列をトリミングする関数とします）。{{ str_limit_ja($question->body, 20) }}このとき、Repository や Service を変更しなくても、Question.php に Accessor を増やせば実装が終わります。Question.php    public function getShortBodyAttribute($value): string    {        return str_limit_ja($this->body, 20);    }このように Accessor を書けば、View では{{ $question->short_body }}で 20 文字にトリミングされた質問文が表示できます。この魅力にハマった我々は、次から次へと改修案件をこの方法で捌いていきました。View にロジックを避けつつ Question に関する処理をまとめて書ける Accessor は優秀だ！と考えました。後々やってくる苦難の道など窺い知る余地もなく・・・発生しうる問題このようにテーブルを起点にクラス設計を固めてしまったある日、こんな要件が発生したとします。【質問一覧では 20 文字まで表示だけど、ユーザーのプロフィールで見れるユーザーの質問一覧には質問本文を 40 文字まで表示してね】いつもどおり Accessor を増やそうとすると、すでにこんな実装が・・・Question.php    public function getShortBodyAttribute($value): string    {        return str_limit_ja($this->body, 20);    }こうなると、諦めて blade にstr_limit_jaを実装するか、medium_bodyのようなヤバいネーミングの Accessor を増やすか・・・みたいな選択肢になってきますね。逆もまた然りです。【こないだの質問一覧の 20 文字さ、ちょっと短すぎるから一覧 → 詳細の遷移率上げるために 30 文字に増やしてよ】よしきた、と変更したところQuestion.php    public function getShortBodyAttribute($value): string    {+        return str_limit_ja($this->body, 30);-        return str_limit_ja($this->body, 20);    }なんと、全く関係なかったはずのユーザーのプロフィールで見れる質問一覧の文字数も 30 文字に増えてしまいました。いつの間にか誰かが profile.blade.php でも$question->short_bodyを使っていたようです。※以上の内容はフィクションですが、実際に似たような事案が何度も発生しました。なぜこのような問題が起こったのか？一言で言えば、【質問データがユーザーからどう見えるかは、ユースケースによって異なるはずなのに、全てのケースにおいて同じ Class のオブジェクトを返して実現していたから】だと考えています。質問個別ページで見る質問質問一覧ページで見る質問プロフィールページで見る質問質問投稿者自身が質問個別ページで見る質問ログアウトユーザーが見る質問、ログインユーザーが見る質問質問を投稿するときに入力する質問といった、サービス内でも様々なユースケースに応じて姿を変える「質問」を、そもそも全て単一の「Question.php」のインスタンスで実現しようとしたことに無理があったはずです。これは User でも近いことが発生してしまっていました。開発していた勉強 Q&A サイトでは、現役の家庭教師や塾講師が学生ユーザーの質問に回答します。それぞれのユーザーはメールアドレスやパスワードなどの認証情報を同じusersテーブルに所有していたことからUser.phpで Model を作成し、取り回していました。これにより、たとえば生徒しか使えない機能を実現する場合でも、理論上全てのタイプのユーザーが入りうる$userが blade にやってくるから余分に if 文を書かないといけない。といった問題が起こっていました。補足Laravel を API サーバーメインとして活用する場合、API リソース(https://readouble.com/laravel/6.x/ja/eloquent-resources.html) という機能を活用すれば、API から返る値を仕様に応じたパラメータに整形する役目を担うレイヤーを作成できます。開発していた勉強 Q&A サイト でも Nuxt で SPA として開発を始めたときや、iOS アプリを開発したときに API を組みましたが、そのときは API リソースを使うことで、リレーションが盛り込まれた Model を最小限にしてクライアントに返すように実装できました。対処療法ではありますが、API リソースによって Model の取り回しによる問題のいくつかは解消できますので、個人的には Laravel の機能で一番好きな機能です。補足２一方、ルートモデルバインディング(https://readouble.com/laravel/6.x/ja/routing.html) は Laravel の中でも指折りのヤバい機能だと思っています。これは Controller で直接 Action Method の引数に Model インスタンスを受け取れるというものです。Controller が Model をいきなり扱えるためレイヤードアーキテクチャの根本から覆してしまいますし、直接 Model を受け取るために、いわゆる N+1 問題を解消するための eager load を行うためのwithメソッドを噛ますことができません。しかし、これも開発時間短縮を実現できるため一時期弊社内で流行し、かなり多用された結果、Question.phpモデル自身にwithプロパティが設定され、質問に関連する全クエリに強制的にwithが走るという状況が発生してしまいました。ヤバいです。設計の問題点を受けての考察ここまで考えて、当時の僕が考えたのは下記のようなことでした。Repository→Service の時点で、Laravel の Eloquent Model を返さず、用途に応じた独自のオブジェクトを返すべきなのではないか？そのオブジェクトはシンプルな PHP の Class（いわゆる POPO）として実装し、プロパティへの型補完が効くように実装すれば透明性も担保できるRepository の役目は Eloquent Model→POPO への変換に特化させるService〜View が扱うオブジェクトは独自オブジェクトだけになるから、影響範囲を絞り込める！このとき僕が考えた【Repository が返してくる独自のオブジェクト】が、DDD の文脈で言うところの【Entity】に落ち着いてくると思うのですが、当時の僕はそこまで考えられていませんでした。ただ、具体的な実装方法が固まりきらなかったためこの考察は考察しただけで終わり、また Model を流用しまくる日々に戻りました。転機そんな日々に転機が訪れ、DDD 実践へ繋がっていった転機が 2 つ有りました。転機 ① スマートフォンアプリ開発1 つ目はネイティブアプリの開発です。Web と同等以上の機能を有する iOS アプリをリリースするにあたって、1 人でアプリで利用する API を全て組みました。初めてスマホアプリ開発に関わって気がついたことは色々ありすぎるので別途記事にまとめられたらと思うのですが、DDD 関連で気がついたことといえば、やはり影響範囲についてでした。ネイティブアプリは Web と違って、リリースするとユーザーがアップデートしない限りこちらから関与することは原則できません（強制アップデートを除く）。今まで Web だけで考えていた影響範囲がアプリにも広がり、さらにアプリもバージョンごとに考えないといけないことを考えると、それら全てのデバイスから質問データにアクセスするときは Question.php を通っているという事実が、恐ろしく思えてきました。さきほどのshort_bodyのような独自 Accessor をアプリ向けの API でも利用しようものなら、もう改修が怖くなって改善スピードが低下する未来が想像できました。結果、Postman を使って API テストを組むことでお茶を濁したのですが、テストは出口対策なので、設計レベルで改善できることはないかな、と考える時間が増えました。転機 ② 　 Web+DB Press の特集【体験 DDD】まあもう今回の記事はこの特集に関して本当にありがとうございました勉強になりましたって言いたいだけの記事と言っても過言ではないのですが笑このころいわゆる Eric 本を買って読んだものの何一つわからず手元で Entity っぽものを組んで、いや違う、こんなの実戦投入できないと頭を悩ませていた中、この特集の話を聞いて速攻買いました。実際に UseCase 層、永続化層、Domain 層の解説とともに（Java ではありますが）生のソースコードが添付されており、非常にイメージしやすい内容になっていました。やはりエンジニアはソースコードで会話するのが一番です。Laravel で DDD を実践するお待たせしました。実際に実務上の施策で DDD を取り入れた設計・実装をやってみた内容をまとめていきます。DDD を実践したときの手順実現する機能に登場する人物、扱われるデータを UML に落とし込み、関係性やそれぞれの成立条件を可視化する機能で実現する UX を「◯◯ が ■■ する」といった主語と述語で表現される文章にまとめるUseCaseを実装。Entity と Repository はモックで、あくまで 2. で作成した文章を実現するように実装するEntityの中にデータの初期化や変更を実装。UseCaseとのインターフェース用に ValueObject を実装最後にRepositoryを作成するためにテーブル構成を考え、Laravel の Model を作成し ORM として永続化・検索処理を実装1. UML 作成まずは実現する機能に登場する人物、扱われるデータを UML に落とし込みます。書くときはPlantUMLという、YAML ファイルで UML を記載できるツールを使って書きました。具体的には、VSCode に PlantUML のプラグインを入れて UML を記述していきます。公式ドキュメントを読めば書き方はすぐにわかります。UML といっても色々あると思いますが、僕はクラス図を使って書いています（もちろん、この時点で、このクラス設計で実装しよう、というものを決定できるわけはないので、ここでクラスとして表現したものに設計が引っ張られないように注意します）。雑にスクリーンショットを貼りましたが、このように YAML ファイルを左に、UML のプレビューが右に出た状態で編集でき、最後に PNG などでエクスポートできます。業界によっては UML を書いてから実装なんて当たり前かもしれませんが、スタートアップで働いていて正直そういった仕様を明記しないことに甘えていたので、久々に UML を書きました。詳しい書き方は「体験 DDD」に書いてありますが、個人的には、各クラスから吹き出しを生やして、制約条件を明記していくところがポイントです。そこで記述した制約条件をできる限り後述するEntity、または ValueObject に徹底的に閉じ込めていくことが重要です。2. 「◯◯ が ■■ する」といった文章にまとめる次に、実現したい機能についてユースケース図を書くか、または「◯◯ が ■■ する」という文章を箇条書きでまとめます。例えば質問投稿機能を作成するとしましょう。質問投稿機能を作るとき、エンジニアであれば【本文やタグといった質問データを受け取り、現在のログインユーザー ID777 とともにデータベースに Insert する】と考えるでしょう。しかし、「◯◯ が ■■ する」の形式で考えれば【学生ユーザーが質問を投稿する】と記載できます（※学生が質問する勉強質問サイトの場合）。後述する UseCase を実装するときに、個人的な考えですが、「◯◯ が ■■ する」の文型で書くように実装することが重要だと思っています。経験上、前述の【データベースに Insert する】という思考で実装すると、Service 層（以下、UseCase 層）のところまでデータベースの構成を意識した実装が漏れ出てきます。データベースのことを UseCase 層より上位のレイヤーが忘れて実装できるように、あくまで現実世界に即した、極論を言えばエンジニア以外の人にも通じるような表現に、実装する機能を落とし込んで記述できることが大事です。補足ここで主語と述語で文章表現することを徹底しなかった僕の失敗談があります。3. UseCase を実装ここまで考えたあと、実装を始めます。最初の実装を Entity などからはじめる方もいるかもしれませんが、僕はいまのところ UseCase から作り始めるのが好きです。UseCase 層は、ユーザーが自社のサービスを利用する場面を表現する層です。さきほど 2. で落とし込んだ「◯◯ が ■■ する」という粒度の情報を持っている層になります。では、さきほどから例示している【学生ユーザーが質問を投稿する】UseCase を実装してみた例を示します。QuestionPostUseCase.php<?phpnamespace App\\QuestionPost\\UseCase;use App\\QuestionPost\\Domain\\ValueObject\\UserAccountId;use App\\QuestionPost\\Domain\\ValueObject\\QuestionBody;use App\\QuestionPost\\Domain\\ValueObject\\QuestionTags;use App\\QuestionPost\\Domain\\Repository\\QuestionerRepositoryInterface;use App\\QuestionPost\\Domain\\Repository\\QuestionRepositoryInterface;use App\\QuestionPost\\Domain\\Entity\\QuestionEntity;use App\\QuestionPost\\Domain\\Entity\\QuestioningUserEntity;use App\\QuestionPost\\Domain\\Exception\\QuestionPostFailedException;final class QuestionPostUseCase{    private $questionerRepository;    private $questionRepository;    // ※ここはLaravelのAppServiceProviderでRepositoryの実体をDIします    public function __construct(        QuestionerRepositoryInterface $questionerRepository,        QuestionRepositoryInterface $questionRepository    ) {        $this->questionerRepository = $questionerRepository;        $this->questionRepository = $questionRepository;    }    public function execute(        // ポイント１　UseCaseの引数はValueObjectがGOOD        UserAccountId $userId,        QuestionBody $body,        QuestionTags $tags    ): QuestionEntity {        // ポイント２　Repositoryから質問者Entityを取得        // @var QuestioningUserEntity        $questioner = $this->questionerRepository->getQuestioner($userId);        // ポイント３　質問者Entityが質問を投稿        // $question は QuestionEntityのインスタンス        $question = $questioner->postQuestion($body, $tags);        // ポイント４　永続化        return $this->questionRepository->saveQuestion($question);    }}ポイント１　 UseCase の引数は ValueObject が GOODUseCase はおおむね Laravel でいうと Controller から呼ばれることが多いですが、その際の引数はValueObject（後述します）がおすすめです。一番いけないと思うのは Array を渡すパターンです。$request->all()でリクエストの内容を取得し連想配列でレイヤーを超えてデータを渡していくことが僕は多かったのですが、内容が不透明になって、結局あとからRepository などで isset feat. 三項演算子地獄を生むことになります。UserAccountIdといった独自の型を定義すれば、より安全に、ヒューマンエラーを防いで扱うことができます。ポイント２　 Repository から質問者 Entity を取得実現したい機能は【学生ユーザーが質問を投稿する】なので、まずは主語となる「学生ユーザー」を用意します。「学生ユーザー」はすでに登録済みのユーザーなので、データベースに永続化されています。そのためRepository 経由でQuestioningUserEntity（１人の質問するユーザーを示すEntity）を取得します。「学生ユーザー」なのでStudentEntityといった名称でも良いかもしれませんが、僕の見解としては、今後仕様変更で学生以外の種別のユーザーが質問可能になる可能性、などの幅を残すために「質問者 Entity」くらい抽象化した命名でもいいのではと考えています。ポイント３　質問者 Entity が質問を投稿※Entity のソースコードは後述します次にQuestioningUserEntityに実装されている（この時点ではモックですが）postQuestionメソッドを実行することで質問を投稿します。引数には質問作成に必要なValueObject（後述します）を受け取り、投稿に成功するとQuestionEntity（質問内容を示すEntity）を返します。ポイントは、QuestionEntity型のインスタンスは、このQuestioningUserEntityに実装されたpostQuestion経由ではないと生成できないように実装することです。するとソースコード上で「質問は必ず QuestioningUserEntity に該当するユーザーが投稿する」ということを暗黙のうちに示すことができます。このように Entity の生成ルートを縛ることで、今回の例だと、「user_id が NULL の質問データをテーブルに Insert してしまう」といった事故を防ぐことができますし、このサイトは必ずユーザーアカウントが存在する場合のみ質問できるのだ、ということをソースを読む人に伝えられます。ポイント４　永続化作成した質問 Entity は Repository によって永続化（＝データベースへの保存）します。Entity の作成と、永続化はわけるほうがお互いの責務が分離されて望ましいと思います。以上で UseCase の解説を終わります。Entity や ValueObject の説明をしないで話を進めるのが辛くなってきたので先に進みますね。4. Entity の実装質問投稿機能の例では現在「質問者 Entity（QuestioningUserEntity）」と「質問内容 Entity（QuestionEntity）」が登場しています。QuestioningUserEntityだけ、実装をざっくり例で示します。QuestioningUserEntity.phpfinal class QuestioningUserEntity{    private $userAccountId;    private $userType;    // ポイント１　最重要！コンストラクタをプライベートにする    private function __construct() {}    // ポイント２　Repositoryが現在のデータを入れる静的メソッドを作る    public static function reconstructFromRepository(        UserAccountId $userAccountId,        UserType $userType    ): QuestioningUserEntity {        // プライベートコンストラクタはクラス内からは呼べます。new self()等でも可        $questioningUser = new QuestioningUserEntity();        $questioningUser->userAccountId = $userAccountId;        $questioningUser->userType = $userType;        return $questioningUser; // 返すのはインスタンス    }    // ポイント３　質問投稿メソッド    public function postQuestion(        QuestionBody $body,        QuestionTags $tags    ): QuestionEntity {        // ここで質問を作成できないユーザーの場合は例外をThrow        if ($this->userType !== UserType::STUDENT) {            throw QuestionPostFailedException::withMessages(                [                    'message' => '質問を作成する権限がありません'                ]            );        }        // QuestionEntityがインスタンス化されるルートがここだけになる→学生以外のユーザーは決して質問を作成できない        $question = QuestionEntity::createByQuestioningUser(            QuestionBody $body,            QuestionTags $tags        );        return $question;    }}ポイント１　コンストラクタをプライベートにするまずはコンストラクタを明示的にプライベートにすることが大切です。インスタンスが作られる方法を特定のメソッドのみに絞ることで、絶対に不整合なデータや思わぬデータをデータベースから取得したり、保存できなくなります。※こちらのコメントで頂いた通り、コンストラクタをこれまで通り Public にしていても、タイプヒンティングや適切な Validation を行っていれば問題ありません。個人的には UseCase からインスタンスを作るときと、データストアからデータを読み込んだときで生成ロジックを変えたいので、このような手法をとっていますポイント２　静的メソッドでインスタンスを作成させるプライベートコンストラクタになったら、どうやって外のクラスがインスタンスを作成するかと言うと、Public かつ Static なメソッドでインスタンスを作って返すようなものを作ります。今回の例だとシンプルですが、プロパティの多いデータの場合は NULLable なデータはここでクラスメンバ変数に NULL を代入するなどします。そうすることで、ソースコード上で、「このメンバ変数は NULLable ですよ」「このメンバ変数は必ず(ValueObject)型の値が入りますよ」ということが表現できます。僕は今まで何度も、「この連想配列のこのキーには何が入っているんだ？」と関数の引数を見て困惑することがありましたが、こうやって生成元を縛ったクラスにしておけば、読み解くのが容易になります。QuestioningUserEntityの場合は生成元が Repository、すなわちデータベースからのデータ読み取り時のみなので、reconstructFromRepositoryという命名にしています。僕の認識が正しければ PHP ではこのメソッドは Repository からしか呼べないといった制限を自然にはかけれないはずなので、仕方なく命名で担保しています。ポイント３　他の Entity を生成するメソッドで制約条件を明記（例外設計についてはまだ自分の中で正解が固まっていないので、このほうが良いと思いますといったご意見をお待ちしています！）QuestioningUserEntityは、postQuestionメソッドで質問作成に失敗した場合、独自で設計した例外「QuestionPostFailedException」を Throw します。ここでの失敗というのは、例えばQuestioningUserEntityに格納されているユーザーが「学生ユーザー」ではなかった場合や、他にも「１時間に１問しか質問できない」といったサービス独自の制約があったときにその制約に弾かれた場合などです。制約条件はpostQuestionメソッド内に集約されていて、UseCase からは条件の詳細を知ることは無いようにします。QuestionPostFailedExceptionは Laravel で用意されているValidationExceptionを継承して実装するのがいまのところおすすめです。というのも、ValidationExceptionのサブクラスが Throw されると Laravel の例外ハンドラ(Handler.php)がステータスコード 422（API の場合）でクライアントに返してくれるからです。例外が API のエラーメッセージやステータスコードを管理しているのが少し責務の位置づけが妙な気もしているのですが、Laravel を使ってきた自分としては自然なのでこの方法でやっています。これらの制約条件をパスしたときのみQuestionEntityが同じような静的公開メソッドによってインスタンス化されて返り値となります。質問作成時にのみ判断できる制約条件がある場合は、このcreateByQuestioningUser内部で実装するイメージです。QuestionEntityの例示は省きます。5. ValueObject(VO)の実装ValueObject は、その名の通り値をオブジェクトとしてよりリッチに表現できる余地を残す仕組みです。さっそく実装内容を示しますが、VO はいたってシンプルではあります。UserAccountId.phpfinal class UserAccountId{    private $id;    private function __construct()    {    }    public static function create(int $primitiveId): UserAccountId    {        if ($primitiveId <= 0) {            throw InvalidUserAccountException::withMessages([                'message' => 'ユーザーIDが不正です'            ]);        }        $instance = new UserAccountId();        $instance->id = $primitiveId;        return $instance;    }    public function toInt(): int    {        return $this->id;    }}僕は Entity と同じ要領で、create メソッドのみからインスタンスを生成できるようにしていて、そこで int は int でも 0 以下の int は許さないよ、といった数値の Validation を噛ませているイメージです。また、実際はデータベースの永続化等で int に直さないといけない場面もあるので、toIntメソッドを実装しています。たったこの程度で実装が終わることが多いので、当初は実装する意味はないかなーと思っていたのですが、結局意義はあるなと思ったので、原則ほとんどの値に対して VO を作っています。ValueObject の意義ValueObject(VO)の意義は主に以下の 3 つあると思っています。メールアドレスの形式検証のように、一般的な検証ロジックを集約する個々の値に対して成立する制約条件を表現する引数を VO にしてレイヤー間のデータをやり取りすることで、引数の順番をミスするなどのケアレスミスを防ぐ検証ロジックに関しては、Laravel ならFormRequestを使ったほうが便利じゃないか、という意見があると思います。しかし、FormRequest の場合、あのクラスの役目は「このリクエストにはどんなパラメータがあるのか、またはそれは必須か」という存在確認と、「それぞれのパラメータの値は【一般的に妥当か】」（メールアドレス検証など）と、「それぞれのパラメータはサービスを成立させる上で問題ないか」（メールアドレスが他のユーザーと被っていないか）というサービス仕様上の検証の 3 つほどの観点が混ざってしまっています。具体的に何が問題かと言うと、弊社のように Web と iOS アプリにサービスを展開する場合、ほぼ似ているけど微妙に入力パラメータの違う API が複数生まれて、それぞれ FormRequest を作成していると、上記で言うところの【サービス仕様上の検証】が複数のファイルにまたがって記述されることになります。すなわち、ある日「ユーザーのメールアドレス重複を許す」という決定が例えば下ったとして（ヤバいけど）、そのときの変更範囲が各プラットフォームごとに発生するということです。それって大袈裟だなというか、Presentation 層に業務ロジックによる Validation が漏れ出ているから変更範囲が広がっているのだなと感じます。なので、僕としては FormRequest は便利なのですが、あれだけで検証ロジック全て終わりではなくて、サービスの仕様に依存するものは ValueObject とか Entity で検証ロジックを表現しよう、と思うのです。メールアドレスの書式検証のような、ユースケースにあまり依存しないものは VO で、メールアドレスが既存のユーザーに被っているかどうか、というユースケースに寄ったものは Entity やドメインサービス（※ここでは書かないですが詳しくは体験 DDD や実践 DDD を参照）に書き込みます。また、関数の引数を VO にすることで、連想配列の中身がわからないとか、引数が全部 int だからうっかり順番を間違えてしまう、というようなミスを防ぐことができます。6. Repository の実装ようやくここまで来て永続化の話ができるようになりました。最初の Laravel の Eloquent Model 依存の設計手法ではテーブル設計から考えていたので、ここまで進めてようやく Repository を考えるというのは、僕にとってはかなり斬新です。もちろんテーブル設計が複雑な場合、結局 Entity や UseCase が引っ張られる可能性はありますが、原則 UseCase や Entity から考えるのが良いと思います。Repository がやることは至ってシンプルです。ここではMysqlQuestionerRepositoryの具体実装を示します。忘れた方は UseCase の説明に戻って、getQuestionerメソッドを使っている箇所を探してみてください。MysqlQuestionerRepository.phpfinal class MysqlQuestionerRepository implements QuestionerRepositoryInterface{    public function getQuestioner(UserAccountId $userId): ?QuestioningUserEntity    {        $userOrm = new \\App\\Model\\User();        $userData = $userOrm->find($userId->toInt());        if ($userData === null) {            return null; // or throw an Exception        }        return QuestioningUserEntity::reconstructFromRepository(            $userId,            UserType::create($userData->user_type)        );    }}Repository の実装のポイントは、なんといってもLaravel の Eloquent Model を ORM でのみ利用するというところです。        $userOrm = new \\App\\Model\\User();        $userData = $userOrm->find($userId->toInt());ここで懐かしの User モデルが利用され、find メソッドによって指定した ID のユーザーインスタンスを取得します。しかし最終的には先述のreconstructFromRepositoryによってQuestioningUserEntityに Wrap され、ID とユーザータイプだけを持ったインスタンスとしてユースケース層に渡っていくこととなります。この方法によって、僕が頭を悩ませていた、Model がどこからでも使われていて影響範囲が読めない問題を防ぎます。ユースケースやドメイン知識ごとに適切な Entity と、その Entity に必要なデータだけ取得、保存する Repository を作成することで、もちろんファイル数やクラス数は爆増しますが影響範囲を絞ることに成功します。テスタビリティも向上することでしょう。※こちらのコメントで頂いたとおり、Repository の実装クラスの命名には、MysqlHogehogeRepository のように永続化しているデータストアの名前を入れるのがふさわしいです。というのも、例えば UseCase のテストコードを書く際に、テスト時にだけ Repository の実装クラスをインメモリの SQLite に永続化するクラス InMemoryHogehogeRepository に差し替えることができるからです。データストアの名前を入れないと、こういったRepositoryの差し替えをしたいときに紛らわしくなりますね。補足ここまでで一通りの説明は終了します。最後に補足をいくつか。UseCase のクラス設計僕は1 ユースケース 1 クラスで作るのが気に入っています。唯一のメソッドexecuteのみを有するイメージです。なぜかというと、UserUseCaseのような抽象的な名前にしてしまうと、なんでもかんでもそのファイルに実装が詰め込まれ、可読性の低下、複雑にするだけの再利用といった結果を生むからです。Interface についてレイヤ間の抽象化に Interface の実装は欠かせません。僕は現状、Repository にのみ Interface を作成し、実装するというルールにしています。UseCase も Interface を作ったほうが良いのかなとは思いますが、単純に手間なのでやっていません。AppServiceProvider.php で Interface と実装を Bind させるように設定しています。どこまで DDD するのか？もちろんサービス全体を DDD で作り直すのが理想でしょうが、正直今の自分にその余裕はないです。弊社がスタートアップというのもありますが、技術都合で DDD に変更しなければならない！というのを押し通すのは難しいなと思っています。とはいえ、現時点で弊社で DDD に挑戦しているのは「サイトに登録している家庭教師への指導依頼＝コンバージョン」と、「学生ユーザーが限定機能を開放する定額課金プラン＝実際に金銭が動く」というサイト内でもかなり高難度かつミスが許されない部分です。こういった特定の機能であれば、ある意味他機能から独立するのが望ましい上に、経営層へ実装に時間をかけ保守性およびテスタビリティを高める説明が自然にできるため、実践したという流れになります。テストは書いているのか？最初テストを書かなかったのですが、DDD で開発していると Entity や VO、UseCase の作り直しが開発の過程でしばしば発生するので、テストを書いていないと変更が億劫になりいずれ手抜き実装が爆誕することが想定されました。現在は PHPUnit を使って、UseCase 単位のテストは書くようにしています。また、結合テストとして HTTP テストも記述しています。詳しくは別の記事などで書ければと思いますが、Laravel ではTestCaseクラスが独自拡張されていて、setUpメソッドをオーバーライドして利用することで Eloquent Model や factory メソッドをテストケースで利用、再利用することができます。setUpメソッドをオーバーライドせずに使うと DI などの Laravel の初期ロード（正式名称なんですかね）が動かないのでテストが書きにくいです。テストも書くとなると、尚更事業優先度が非常に高いところからチャレンジするのが向いているなと感じているところです。ディレクトリ構成は？下記のようなディレクトリ構成でやってみています。既存設計がもうそこそこの規模になっているので、ルートディレクトリごと分けてしまっています。app/├── Console├── Constant├── Domain // ここのディレクトリ配下はDDDのアプローチで設計・実装している│   ├── { DomainName } // 扱う事業領域名│   │   ├── Domain // ドメイン層│   │   ├── Infrastructure // 永続化層│   │   └── UseCase // ユースケース層（旧設計がServiceという単語を使っており、意識して分けるためにUseCaseとした）│   ├── { DomainName }│   ├── { DomainName }│   ├── ...│   ├── Base // DDD全体でベースとなるClass。将来的にはEntityやVOの基底クラスも作りたい│   │   └── Exception // ValidationExceptionを拡張したclassを配置│   ...├── Events├── Exceptions├── Helpers...まとめ旧質問投稿 UseCaseDDD をやる前だったら、質問投稿時の UseCase（Service 層）はこんなシンプルな実装になるでしょう。QuestionService.php    public function postQuestion(array $params, int $userId)    {        $question = $this->questionRepository->storeQuestion($params, $userId);        return $question;    }この実装に比べれば、これまで説明した実装は、ソースコードが仕様を説明し、適切な制約をかけているという観点で非常に情報量が多い実装になっていることがわかると思います。結論Laravel の Model をあらゆるレイヤーで使うと改修が難しくなる開発する機能のユースケースを主語と述語で文章に表現し、そのまま UseCase 層の実装として表現するEntity や ValueObject に制約条件をまとめ、適切に例外を吐くLaravel の Model は ORM としてのみ利用する！！PHP の言語自体の限界はあるので、命名の工夫などで適宜我慢する実運用の際はどの機能から、どこまで完璧主義で DDD をやるか考える以上です思った以上に長文になりましたが、今の自分の DDD の実力はこんなところです。もっと上手に設計できるように経験を積んで、運用を経て痛い目に遭っていこうと思います！しかしやっぱり型のある言語がいいですね。最近はフロントもバックエンドも TypeScript で組むのが良いんじゃないかと思えてきています（過激派）。ぜひ Twitter でも繋がっていただけると嬉しいです。https://twitter.com/Meijin_garden求人告知！また、私が CTO を務めている「オンライン家庭教師マナリンク」では、エンジニアを募集しております。2020 年 12 月 現在、Web エンジニア及び、React Native エンジニアを探しております。募集ツイートマナリンクでは、オンライン家庭教師の先生方のために、サイト上で自身のプロフィールを魅力的に発信できるようにしたり、オンライン指導専用アプリをリリースするなど、次々にプロダクトを開発しています。日々新しい技術を勉強して、試す機会を探している方にはうってつけな環境です。事業の成長を優先させながら、ソースコードやアーキテクチャの品質にもこだわりたい方、ぜひ上記の私の Twitter に DM でご連絡をください！","link":"https://qiita.com/mejileben/items/302a9f502ca0801b1efb","isoDate":"2019-12-09T07:53:33.000Z","dateMiliSeconds":1575878013000,"authorName":"Meijin"},{"title":"Nuxt2.10.2と@nuxt/typescript-build環境でtypescript3.7以降を入れているとbuild失敗する","contentSnippet":"概要ハマったのでメモです。自社サイトのNoSchoolにTypeScriptを導入したのですが、npm run build時に失敗してしまって、結果TypeScriptのバージョンを巻き戻したら治りました。環境Nuxt v2.10.2@nuxt/typescript-build v0.3.2TypeScript 3.7.2補足TypeScript3.7を入れていたのは、最近Optional Chainingが出て話題だったのでNuxtで使えないかなと思って入れたのがきっかけだったのですが、その後、VSCodeでvetur.useWorkspaceDependenciesをTrueにして利用することにしたので入れていました。なので、あくまで開発環境でVeturを動かすことを目的として、devDependenciesのほうにTypeScriptを入れていました。package.json  \"devDependencies\": {    ...,    \"typescript\": \"^3.7.2\",    ...  }起こったことnpm run devは通っていたのですが、npm run build時に下記ログで失敗しました。ERROR in /opt/noschool/client/node_modules/@nuxt/types/config/build.d.ts(18,10):18:10 Import declaration conflicts with local declaration of 'FileLoaderOptions'.    16 | import { Options as OptimizeCssAssetsWebpackPluginOptions } from 'optimize-css-assets-webpack-plugin'    17 | import { TerserPluginOptions } from 'terser-webpack-plugin'  > 18 | import { Options as FileLoaderOptions } from 'file-loader'       |          ^    19 | import { Options as PugOptions } from 'pug'    20 | import * as Less from 'less'    21 | import { Options as SassOptions } from 'node-sass'原因の探し方まずはImport declaration conflictsでググってみると、下記issueが見つかりました。https://github.com/angular/protractor/issues/5348結局ここにTypeScriptのバージョンを下げたら治ったといったことが書いてあるので、自分の手元でもTypeScriptを3.6.4に戻してみたらbuildが通りました。package.json  \"devDependencies\": {    ...,    \"typescript\": \"^3.6.4\",    ...  }結果として3.6.4に戻した格好になります。そもそも@nuxt/typescript-buildがTypeScript3.6を対象にしているので、合わせるのが無難でしたね。https://github.com/nuxt/typescript/blob/master/packages/typescript-build/package.json下記の記事でNuxtではTypeScript3.7は使えないと書いてありますが、使えないとは具体的にどういう意味だったのかはわからなかったので、今回buildが失敗して実感しました。https://qiita.com/simochee/items/a2eca2ea8761409889beわからないこととはいえ3.7以降だとなぜダメで、3.6に戻すと治ったのかはよくわからず。僕自身としては3.6から3.7になってOptional Chaining以外に何が変わったのかよく知らないので、調べてみてわかったら追記します。とりあえず上記のエラーメッセージでググったときに記事がほとんどなかったので、QiitaのSEOにあやかって同じミスでハマってしまった方がすぐに解決できたら嬉しいです。","link":"https://qiita.com/mejileben/items/fd1dffd1428513503be3","isoDate":"2019-12-05T05:25:18.000Z","dateMiliSeconds":1575523518000,"authorName":"Meijin"},{"title":"【Sign in with Apple】既存サービスに追加で実装するときに役立つ資料まとめ（2019年9月版）","contentSnippet":"概要2019年9月12日から、新規でApp Storeに提出されるアプリかつ、ソーシャル（サードパーティ）ログインを実装しているアプリにはSign in with Appleの実装が必須になっているそうです。https://developer.apple.com/news/?id=09122019bStarting today, new apps submitted to the App Store must follow these guidelines.https://developer.apple.com/app-store/review/guidelines/#sign-in-with-appleApps that exclusively use a third-party or social login service (such as Facebook Login, Google Sign-In, Sign in with Twitter, Sign In with LinkedIn, Login with Amazon, or WeChat Login) to set up or authenticate the user’s primary account with the app must also offer Sign in with Apple as an equivalent option.唐突すぎて信じがたいですが英文を何度読んでもそういう状況だということで、いろいろ調べてみましたのでその情報をまとめます。背景としては、私自身が自社でiOSアプリを開発中で、既存Webサービスのアプリ化のためTwitterログインやメールログインが既に存在し、そのあたりとの連携も実装不可避になっています。既存サービスへの追加のため、既存ユーザーがSign in with Appleに乗り換えたときのアカウントのIDを連携するようなユースケースに置かれた方々に参考になれば、と思って書きました。想定読者現在すでに運用しているWebサービスのアプリ版をリリースしようとしているアプリエンジニア・サーバーサイドエンジニアおよびそれと近しい状況に置かれている方Sign in with Appleの仕組みなんもわからん、という方役立った資料一応公式サーバーサイドでSign in with AppleしたユーザーのID連携をするときは、このあたりが公式ドキュメントになります。https://developer.apple.com/documentation/Signinwithapplerestapi/verifying_a_userhttps://developer.apple.com/documentation/Signinwithapplerestapi/authenticating_users_with_sign_in_with_appleしかし情報がなさすぎて正直意味がわからないため、常にブラウザの固定タブで開いておきつつ、以下に示していくような非公式のWebサイトを順次巡りながら、公式に書かれていることと照らしていくような進め方を推奨します。全体の流れhttps://www.slideshare.net/techblogyahoo/sign-in-with-apple-ios-idconバックエンドサーバで管理しているIDと、Sign in with Appleで得たIDをどうやって連携するかの全体的なフローがシーケンス図で書かれています。フローの考え方としては、1. クライアントアプリでSign in with AppleしてAuthorization CodeおよびID Token(JWT)を取得Authorization CodeまたはID Tokenを検証し、成功すればログイン処理を行うとなります。いくつかやり方が提示されていますので、好みというか要件に沿って選べばいいと思います。プライベートメールアドレスの仕組みについて上記のスライドには、Sign in with Appleの大きな特徴である、「ユーザーがプライベートなメールアドレスをサービス側に登録し、自身の本当のメールアドレスは隠蔽する」という仕組みについても書かれています。これはApple側で、「ユーザーの本当のメールアドレスとランダムに作成した偽のメールアドレスをリレーする」仕組みを用意していて、サービス側に伝えるのは偽のほうにしておくというものです。サービスから通知とかメルマガで偽のメールアドレスに送ると、Appleのメールサーバー側で転送してくれます。何の意味がある仕組みかというと、普通、ユーザーがサービスを退会してもサービス側でユーザー情報を論理削除するか物理削除するかなんて利用規約次第なところがあって、論理削除の場合はずっとメールアドレスを保持されるためなにかの拍子に流出するリスクなどがあります。それを根本的に防ぐことができる仕組みです。68枚目のスライドにめっちゃ重要なことが書かれていて、ユーザーはApple IDの管理画面からサービスとの連携を解除するというのができて、その場合はプライベートメールアドレスは変わってしまうため、再度Sign in with Appleしたときにメールアドレスの更新処理をする必要があります。要は初回のSign in with Appleなのか、何回目かのSign in with Appleなのか、連携解除後の再度Sign in with Appleなのかで処理が変わってくるわけで、気をつけてテストしないと取り返しのつかないことになりそうです。必要なシークレットやclient_idの生成方法https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple英語ですが、このサイトが非常によく書かれています。実際にサーバーサイドからAuthorization Codeを検証するリクエストを飛ばそうと思ったら、client_idと呼ばれるよくわからないIDに、client_secretというよりよくわからないシークレットを付けて投げることになります。https://developer.apple.com/documentation/Signinwithapplerestapi/verifying_a_userそもそもAppleのコンソールからSign in with AppleをONにする必要があり、その中で発行されるKeyを使ってclient_secretをJWTで生成するといった特徴的なフローがあります。特にclient_secret生成が面倒で、秘密鍵やKey ID、client_idといったいくつかの値を使ってJWTを生成しています。上記記事ではRubyで書いてありますが、ちゃんと動きますのでこのまま利用できます。ありがたや〜client_secretはいくつかの値を使ってJWTを作成したものなのですが、有効期限が半年に設定されるのが一般的なため、実運用にあたっては定期的に上記Rubyコードを実行する体制を整え、かつ生成したJWTをどこかセキュアなところに保存しておいてプロダクションのサーバーからその値を読み取るような仕組みが必要かと思います。私はAWS Parameter Storeを使っているので、LambdaでRubyを書いて定期実行でParameter Storeに突っ込むなどの方法を検討中です。具体的なリクエストやレスポンスhttps://www.slideshare.net/naohiro.fujie/idaassign-in-with-apple実際にSign in with Apple時に利用するエンドポイントを利用するときにどんなJWTが返ってきたり、どんなJWTを投げるかという踏み込んだ部分について書いてあります。あと、私は使いませんでしたが、Auth0についても書いてあるので、Auth0使っている人は参考になるかもです。ユーザーのメールアドレスや名前を得るタイミング上記のスライドにはハマりやすいポイントが書いてありまして、「認可レスポンスにユーザー自身のメールアドレスや名前が返ってくるのは初回のみ」ということです。そのユーザーにとって一度目または連携解除後の初回のSign in with Apple時のみ、認可エンドポイントを叩いた後のレスポンスにユーザー自身のメールアドレスや名前が含まれているということです。Sign in with Appleしたユーザーを既存ユーザーと紐付けたいとなれば、メールアドレスで紐付けるのが定番かと思いますが、この初回タイミングを逃してしまえば連携を解除してもらわない限りできなくなってしまうので要注意です（自動で連携するのではなく、プロフィール画面などに連携するボタンがあり、押したら連携するようなUXにすれば対応可能かとは思います）。まとめまずはヤフーさんのスライドを読んで、どういったシーケンス図で実装しようかという目立てをします。次に、紹介した英語の資料を読みながら、Appleのコンソールで秘密鍵の作成やSign in with AppleをONにします。client_secretの生成もやってみます。ここまで終わったら、Sign in with Appleのボタンを実際にアプリやブラウザに配置して押してみましょう。ブラウザならこちらの記事、https://developer.apple.com/documentation/Signinwithapplejs/configuring_your_webpage_for_sign_in_with_appleアプリならこのあたりが参考になります。https://developer.apple.com/documentation/authenticationservicesボタンを押してみると、ブラウザの場合はredirect_urlで指定したエンドポイントへのリクエストに、アプリからならコールバックでのイベントハンドラでAuthorization CodeやID Token、また初回リクエストの場合はメールアドレスや名前が返ってきているはずです。次に、バックエンドでID連携処理をやるためにAuthorization CodeやID Token、およびメールアドレスや名前を自前で構築したバックエンドAPIに投げます。バックエンドではID TokenのJWTを復号して中身のissとかsubが妥当かチェックする、またはAuthorization Codeを/auth/tokenエンドポイントに投げてCodeの検証をします（補足ですが、前述のclient_secretが必要云々はAuthorization Codeの検証をするパターンの場合のみです）。Authorization Codeの検証の場合は、リクエストが成功して、かつAppleへのアクセストークンなど含まれた正常なレスポンスになっていることがチェックできたら、ID連携処理を実行して、必要なアクセストークンをアプリ側に返してあげることでログイン処理完了とする、というフローがいいと思います。最後に公式ドキュメントの情報が少なすぎて錯乱しましたが、結果、かなりユーザーフレンドリーでセキュアに設計されたいい仕組みだなあと思っています（洗脳されただけかも）。もし私と同じような状況で実装した方がいらっしゃったらぜひ情報共有しましょう。Twitterhttps://twitter.com/Meijin_gardenまた、弊社では中高生が利用する勉強質問サイトを運営しています。週1〜の副業から一緒に開発するメンバーを募集中ですので、Webエンジニア、iOSエンジニアの方はいつでもお問い合わせください！https://www.wantedly.com/companies/noschool","link":"https://qiita.com/mejileben/items/df79024ae93971643271","isoDate":"2019-09-30T03:48:22.000Z","dateMiliSeconds":1569815302000,"authorName":"Meijin"},{"title":"2万枚以上から探せる画像検索をCloud Vision APIとAlgoliaを使って開発した話","contentSnippet":"概要2万枚以上の勉強に関する画像から、手元にある問題集の写真で同じ問題の画像を検索できる機能をリリースしました。TL;DROCRと全文検索の組み合わせを使えば、文字量が多い画像の画像検索ができるCloud Vision APIの日本語解析の性能はいい感じAlgoliaはパラメータの調整によって「長文で長文を検索する」ユースケースにも対応できるAlgoliaとLaravelの連携は、Eloquent Modelを使っているならめっちゃ便利できあがったもの先に完成した画像検索機能をお見せします。検索する画像はこちらです０．画像検索ページを開く悲報：画像検索機能は撤退することになり削除されました。画像検索機能はこちらのURLから利用できるので、手元に手頃な問題集がある方（？）は使ってみてください。１．まずは問題の科目を選択します２．次に検索したい画像をアップロードします３．検索結果の一番目に出てきた質問は、検索した画像と同じ問題ですヒットした質問の詳細ページはこちらです本記事では、この画像検索機能を開発するために活用したCloud Vision APIやAlgoliaなどの概要と、その組み合わせ方、ハマったポイントなどについてお話します。背景筆者について勉強質問サイトNoSchoolを運営する株式会社NoSchoolでCTOをしています。理論上最小のCTOとして毎日一人でもくもく開発しています。https://noschool.asia/questions開発のきっかけ毎日質問と回答が溜まっていくわけなので、いずれは質問しようとした瞬間に、過去の質問と一致していたり、近いものがあるならばそれをレコメンドするという世界観だって作れるはずです。大半の勉強の質問は問題集の写真や教科書の写真とともに投稿されています。ということは、手元の問題集の写真を撮影しNoSchoolにアップロードすると、質問の本文を打たなくても過去の質問から類似したものが返ってくるというものができたらいいのでは、と思い立ち、今回の画像検索開発をすることになりました。技術選定僕は日頃からWeb開発に注力しており、スキルマップとしてはAWS、Firebase、Laravel、Nuxt.jsあたりを触っています。機械学習に関してはなんとなく勉強したことはあるものの、自分でモデルを学習させるようなことはほとんどやったことがないです。特徴量算出は微妙かも画像の特徴量を算出するAKAZEやORBといったアルゴリズムは存在するし、一般にはかなり高精度で似ている画像を判別できるのですが、そもそも数万枚以上の画像から近い特徴量の画像を探すというのは別の技術が必要になるというのと、ここでの「似ている」というのは勉強の質問を検索する際に必要な「似ている」とはちょっと違うなと思いました。PythonでAKAZE/ORBで特徴量を出して検索できるスクリプトを書いて実行したが、良いような悪いようななんともいえない感じでした。なにしろ勉強の質問の画像は基本的にくすんだ紙に文字がざっと印刷されているだけなのです。素人の僕がこれ以上のめり込んでも短期間では成果を出せない可能性が高いと判断しました） Python + OpenCVで画像の類似度を求める AKAZE特徴量による画像マッチングというのも、先程の例では全く同じ質問がヒットしましたが、全く同じ質問が弊社のデータベース内にあることを保証できるわけでは有りません。全く同じ質問が無いときは、理想で言えばその質問と同じ単元の質問くらいを出してやりたいところです。OCR✕全文検索はどうか同じ単元の質問を複数枚の画像から探すには、画像が似ているかどうかも重要ですが、画像の中に含まれている文字がどれくらい近いのか、というのも重要だというように考えました。勉強の質問というのは、「還元剤」とか「平方根」とか珍しい言葉が多く入っています。「還元式」が入っていたらほぼ化学ですし、化学の中でも酸化と還元を扱っている単元である可能性が高いです。ここまで考えて、「OCR」と「全文検索」の組み合わせというアイデアが浮かびました。そもそも画像検索というのは「画像解析」と「大量の解析後データから検索する技術」に分解されるわけで、まともに特徴量を求めるやり方だと前者も後者も難しい上に勉強の画像で成果が出るか微妙、という懸念がありました。Cloud Vision APIを始めとして各種クラウド等からいい感じに日本語対応もしたAPIが色々と出ていますし、全文検索は最近巷でよく見るAlgoliaを思考停止で使えばいいのではと思い、この方法なら技術的にも実現できそうだし、勉強の質問という特殊な画像データにおいて検索できる可能性が少しでも高いのではないか、と考えました。Cloud Vision APIの採用AWSのRekognitionはたしか日本語に対応しておらず、精度も全然だったのですが、GoogleのCloud Vision APIは最初使ったとき震え上がったほど精度が良かったので採用しました。Azureも精度が高いという話は聞いているのですが、Cloud Vision APIでそこまで困らなさそうだった＆Firebaseを自社で使っているので既にGCPにクレカが登録されていて楽だった（）という理由でCloud Vision APIにしました。Azureも検証してみたいです。Algoliaの採用全文検索でAlgolia以外を知らなかったですし、ものは試しと使ってみるとLaravelとのIntegrationもあるというので、採用しました。他の選択肢をご存知の方がいればぜひ教えて下さい！実現方法ということでCloud Vision APIとAlgoliaを採用したので実現方法の話に移ります。データの生成過去画像を全部OCRしてデータベースに突っ込むまずはサクッと画像をCloud Vision APIに投げて結果をデータベースに投げるLaravel Commandを書いて実行しました。AlgoliaとのIntegrationに便利だからです。また、質問データとリレーションをModelで張っておくことで、OCRしたテキストの他の活用も望めます。Laravel ScoutLaravelにはScoutという、全文検索エンジンとEloquentモデルを同期してくれるライブラリをサポートしています。https://readouble.com/laravel/5.7/ja/scout.htmlLaravelのEloquent ModelでSearchableトレイトをuseし、あとはドキュメントに書いてあるとおり、Algoliaに投げるパラメーターを指定します。僕はQuestionImageという質問添付画像のModelに対してSearchableトレイトをuseして統合し、OCR後のテキストをdetected_textとして扱うように設定しています。toSearchableArrayメソッドを実装し、その中でAlgoliaに投げたいデータをreturnすればいいです。OCRが失敗する画像も中にはあるので、失敗してnullになっている画像はAlgoliaに投げないとか、Algoliaに投げれるデータは１レコード当たり10,000バイトなので、OCR後のテキストが10,000バイトを超えたらそこまでmb_strcutするように実装するなど工夫しています。実装が終わったら下記コマンドを実行します。php artisan scout:import \"App\\{モデル名}\"実行中にAlgoliaのコンソールにいけば、データが次々入っていることを確認できるでしょう。データの検索検索用のAPI冒頭で示したようなUXを想定しているので、画像を投げたらその画像で過去の質問の画像を検索し、ヒットした質問一覧を返すようなAPIを実装しました。Algoliaから検索する処理を分離して、例えば将来的にネイティブアプリからML KitですでにOCRされたテキストが渡ってくるようなユースケースにも対応可能にしておきました。Algoliaの中からデータを探すときも、Model->searchメソッドで検索できるので、Scoutは本当に便利です。            $searchResult = QuestionImage::search(                $detectedText,                // Algoliaの検索オプション指定                function ($algolia, $query, $options) use ($subjectId) {                    $options['getRankingInfo'] = true;                    // 中略                    return $algolia->search($query, $options);                }            );Algoliaの検索パラメータ実はここが一番肝なのですが、Algoliaの一般的なユースケースは数個の単語で全文検索をする場面です。ユーザーの画像もOCRした上でそのテキストで検索するため、【長文で長文を検索する】ことになります。この場合、独自でAlgoliaの検索パラメータを調整する必要があります。最終的に決定してリリースしたパラメータは検証の末に調整したものなので、ここに貼るのはやめておきますが、もし同じく長文で長文を検索する状況になった方は、パラメータのドキュメントを読み込んで何度も検証することをおすすめします。検索結果の活用Algoliaは検索後に戻ってくるJSONにも便利な情報が入っていて、どれくらい文字列間に距離があったか（おそらくハミング距離のようなもの）が含まれています。これを自社の画像で何度か検索してその結果と距離を目視で照らし合わせると、だいたい距離がどれくらいの数値を下回っていたら同じ画像かというのがわかってきます。そこで、クライアントサイドにAPIの戻り値として最も小さい距離を返してあげることで、「検索結果内におそらく望ましい画像がないだろう」という前提に立った処理が実装可能です。まとめOCRと全文検索の組み合わせを使えば、文字量が多い画像の画像検索ができるCloud Vision APIの日本語解析の性能はいい感じAlgoliaはパラメータの調整によって「長文で長文を検索する」ユースケースにも対応できるAlgoliaとLaravelの連携は、Eloquent Modelを使っているならめっちゃ便利ちなみに実装期間はフロントエンドの実装まで全て含めてだいたい3週間弱です。最後にもしよかったら Twitter （https://twitter.com/Meijin_garden ）もフォローお願いします！","link":"https://qiita.com/mejileben/items/3ad7a760db799ab92611","isoDate":"2019-09-25T09:36:29.000Z","dateMiliSeconds":1569404189000,"authorName":"Meijin"},{"title":"ハッピーエンドについて考えさせられた話（小川糸「にじいろガーデン」感想）","contentSnippet":"株式会社NoSchoolという教育ベンチャーでCTOをしている名人です。ベンチャーで仕事に忙殺されていると感性を失いそうになるので、意識して映画や小説を摂取しています。続きをみる","link":"https://note.com/meijin_garden/n/nac491de23d66","isoDate":"2019-09-08T14:01:19.000Z","dateMiliSeconds":1567951279000,"authorName":"Meijin"},{"title":"株式会社LIFULLを退職し、教育スタートアップのCTOとして転職します","contentSnippet":"前書きこんにちは。都内でWebエンジニアとして働いている名人です。続きをみる","link":"https://note.com/meijin_garden/n/n2d60b28569a8","isoDate":"2019-03-24T09:28:42.000Z","dateMiliSeconds":1553419722000,"authorName":"Meijin"},{"title":"Twitterのフォロワーが1,000人超えました。「与えることから始める」を心がけることについて。","contentSnippet":"概要Twitterのフォロワーを自己中心で増やさないための「与えることから始める」姿勢について、書きます。続きをみる","link":"https://note.com/meijin_garden/n/n854a275aa729","isoDate":"2019-01-16T13:58:57.000Z","dateMiliSeconds":1547647137000,"authorName":"Meijin"},{"title":"解決したい課題が見つかったらとにかく「小さく始める」から始めたらいいんじゃないかな","contentSnippet":"前置きこんにちは。都内でWebエンジニアをしながら、スタートアップで副業したり社内新規事業立ち上げをやっている名人です。年末年始で地元の奈良に帰省していたのですが、東京に戻る新幹線でふと思い立ったので #note書き初め をしました！続きをみる","link":"https://note.com/meijin_garden/n/n064b7dc12a58","isoDate":"2019-01-05T12:06:20.000Z","dateMiliSeconds":1546689980000,"authorName":"Meijin"},{"title":"イベントに参加してその場でブログを書き上げてみた！〜未来の住生活が詰まったカンファレンス「Living Tech2018」編〜","contentSnippet":"はじめにトークセッションや講演形式のイベントに参加したけど、話を聴いているだけで眠くなってきて、結局メモもろくに残さず学びもなく終了・・・続きをみる","link":"https://note.com/meijin_garden/n/nf1fc0c2d2397","isoDate":"2018-11-21T14:34:20.000Z","dateMiliSeconds":1542810860000,"authorName":"Meijin"},{"title":"イベントに参加してその場でブログを書き上げてみた！〜地域福祉×PIECESトークイベント編〜","contentSnippet":"はじめにトークセッションや講演形式のイベントに参加したけど、話を聴いているだけで眠くなってきて、結局メモもろくに残さず学びもなく終了・・・続きをみる","link":"https://note.com/meijin_garden/n/n01aeabbe9967","isoDate":"2018-11-17T12:59:13.000Z","dateMiliSeconds":1542459553000,"authorName":"Meijin"},{"title":"【SEO超入門】個人開発しているサイトで、特定のキーワードでSEO1位取るまでにやったこと","contentSnippet":"対象読者・SEOのSの字もわからない人・SPAのサイトでSEO対策できるのかな？と思っている人続きをみる","link":"https://note.com/meijin_garden/n/n7cff8dfd398c","isoDate":"2018-10-14T15:27:49.000Z","dateMiliSeconds":1539530869000,"authorName":"Meijin"},{"title":"SEOを考えることは、サイトの提供...","contentSnippet":"SEOを考えることは、サイトの提供価値を見つめ直すことなんだなあめじを 続きをみる","link":"https://note.com/meijin_garden/n/n09dd99153543","isoDate":"2018-10-11T12:52:29.000Z","dateMiliSeconds":1539262349000,"authorName":"Meijin"},{"title":"畑違いの人に”わかった気”になってもらう「ざっくり説明」のススメ","contentSnippet":"概要・背景こんにちは。都内でWebエンジニアとして働いている名人です。続きをみる","link":"https://note.com/meijin_garden/n/nfa484f612a20","isoDate":"2018-09-06T02:46:44.000Z","dateMiliSeconds":1536202004000,"authorName":"Meijin"},{"title":"好きなことで、生きていく。のではなくて、「好きなことで、かつ誰とも比較できないことで、生きていく。」","contentSnippet":"こんにちは。都内でWebエンジニアとして働いている名人です。趣味で将棋をやっていることから、かれこれ8年ほどニックネームで名人と呼んでもらっています。続きをみる","link":"https://note.com/meijin_garden/n/nf5a19f497f93","isoDate":"2018-06-17T15:35:09.000Z","dateMiliSeconds":1529249709000,"authorName":"Meijin"},{"title":"家にPCもネットもスマホも無かった中学3年生が、高専に入学し5年後Webエンジニアになった話","contentSnippet":"こんにちは。都内でWebエンジニアとして働いている名人です。趣味で将棋をやっていることから、かれこれ8年ほどニックネームで名人と呼んでもらっています。続きをみる","link":"https://note.com/meijin_garden/n/n71029117558e","isoDate":"2018-05-07T16:24:47.000Z","dateMiliSeconds":1525710287000,"authorName":"Meijin"}]
